{"pages":[{"title":"Page not found · PingBook Blog\r\n","text":"\n\n\nPage not found · PingBook Blog\r\n\n\n\n\n\n\n\n\n\n\n\n\n\n\r\n                (adsbygoogle = window.adsbygoogle || []).push({\r\n                    google_ad_client: \"ca-pub-1893384651266286\",\r\n                    enable_page_level_ads: true\r\n                });\r\n            \n\n\n\r\n                window.dataLayer = window.dataLayer || [];\r\n                function gtag(){dataLayer.push(arguments);}\r\n                gtag('js', new Date());\r\n\r\n                gtag('config', 'UA-122219517-1');\r\n            \n\r\n            (function(){\r\n                var bp = document.createElement('script');\r\n                var curProtocol = window.location.protocol.split(':')[0];\r\n                if (curProtocol === 'https'){\r\n            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';\r\n            }\r\n            else{\r\n            bp.src = 'http://push.zhanzhang.baidu.com/push.js';\r\n            }\r\n            var s = document.getElementsByTagName(\"script\")[0];\r\n            s.parentNode.insertBefore(bp, s);\r\n            })();\r\n        \n\n\n\n\n\n\nPingBook Blog \n\n\n\n\nHome\nCategory\nArchive\nTags\nAbout\nChanges\n\n\n\n\n\n\n\n\n\n\n\n\r\n                (adsbygoogle = window.adsbygoogle || []).push({});\r\n            \n\n\nThat page doesn't exist!\n\n\n\n\nSorry, but the page you are looking for cannot be found. It seems that the page you were trying to reach doesn't exist, or may be it has just moved, or it no longer exists.\nThe best thing to do is to use the search form or start again from the home page.\n\n\n\nSearch\n\n\n\n\n\n\n\n\n\n\r\n                ©\r\n                document.write(new Date().getFullYear())\r\n                PingBook.top. Powered by Pelican.\r\n                \n\nSite Views: ,\r\n                    Total Vistors: \n\n\n\n\n\n\n\n\n\n\n\n\r\n    var disqus_shortname = 'pingbook';\r\n    (function () {\r\n        var s = document.createElement('script'); s.async = true;\r\n        s.type = 'text/javascript';\r\n        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';\r\n        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);\r\n    }());\r\n\n\n\n\r\n    function validateForm(query) {\r\n        return (query.length > 0);\r\n    }\r\n\n\n\n\n","tags":"","url":"https://pingbook.top/404.html"},{"title":"Blog Profile","text":"My name is Walter Hu , I am a full-stack developer currently working as a software developer at Shanghai. I am the website founder. I also participated in Vue and selenium last year as a contributor. I have also worked at HP and various other startups mainly working on Web, Desktop and Android. Achievements Designed and implemented new selenium framework(cucumber, BDD .etc). Best practise for Vuejs framework with element-ui or vuetify and vux . Best production practise for springboot project. Website https://yitieyilu.com founder and CTO . About this site This place is an evolving notebook where I deposit tiny pieces of knowledge ( knowledgelets ?) I generate in my personal and professional activities. Everything's in English as a way to practice, and to make my knowledge available to the largest audience. It's not my mother tongue and you'll surely find mistakes. If you do, please be kind enough to comment on the blog (or better, send a pull-request ) so I can quickly fix errors. I sometimes write in Chinese to target a French-speaking audience.","tags":"pages","url":"about"},{"title":"Break Changes","text":"2018-07-01 0x01 pelican blog site setup Add into google and baidu search enginee. Add the tipue search for static site search. Change some css styles and layout. Add google adsense.","tags":"pages","url":"change-log"},{"title":"Flask中的FileStorage第二次调用的内容为空( 0KB )","text":"问题 我在使用 Flask 上传文件的时候,需要把文件一份保存到本地一份保存到七牛云. 在这里如果先调用如下代码,然后在保存到七牛云的时候发现保存的文件是0KB. file = request . files . get ( 'file' ) file . save ( filesavedpath ) # 此处保存到本地 # 开始的时候我以为是file.save中调用的保存文件的操作中执行了如下的close操作导致文件流关闭了,所以继续使用file对象读文件结果就是空的了 file . save的源码如下 : from shutil import copyfileobj close_dst = False if isinstance ( dst , string_types ): dst = open ( dst , 'wb' ) close_dst = True try : copyfileobj ( self . stream , dst , buffer_size ) finally : if close_dst : dst . close () 所以我把先保存到七牛云的代码放在 file.save() 的前面,如下代码保存到七牛云: # 首先获取对应的FileStorage对象, # 1. 第一种方式 request.files.get('file) # 2. 第二种方式 streamio = BytesIO(r.content) # 将对应的bytes转换成stream的bytes file = FileStorage(stream=streamio, filename=mediaid + '.jpg') # 3. FileStorage转换成字节数据(二进制数据) <<此处重点>> filestream=file.stream.read() # 调用七牛云SDK auth=Auth(ak,sk) # 构造Auth对象 token=auth.upload_token(self.__bucketname,key=key,expires=3600) # 获取accesstoken responseData,info=put_data(token,key,filestream) # 调用put_data保存二进制数据 结果发现第二次保存到七牛云的时候保存的文件还是0KB,无语了….. 回家反复查看Google,模糊的记得好像python的 read 读文件有一个限制: python在读取文件的时候是根据光标位置来读取的。读一行以后光标位置到了下一行。再来个read又到了下一行。 想要重新从头开始读的话用f.seek(0) 将光标位置放到最前面。这样再f.read()就是第一行的内容 还有个方法是f.tell() 告诉你当前光标的位置。你可以把文件都读完了以后f.tell()一下看看光标位置 然后再f.seek(0) 再f.tell()一下看看光标位置 解决方法 # 调用完save()或者read()后, 使用tell() 函数判断一下光标,然后使用seek(0)定位到开始的位置 position=file.tell() if position!=0: file.seek(0)","tags":"Python","url":"articles/flask-filestorage-zero/"},{"title":"Vue项目调试总结-WebStorm+Chrome调试(2018-09-15)","text":"转自: Vue项目调试总结(1)-WebStorm+Chrome调试 - 为程序员服务 http://ju.outofmemory.cn/entry/354985 最新更新 Vue中所有variables都是 undefine 问题 2018-09-14 因为在webstorm里面debug vue文件的时候发现所有的变量都是undefined,所以我提了一个defect 在他们的仓库中,详见 https://github.com/JetBrains/webstorm-samples/issues/1 ,他们的Manager还是很给力,很快给了答复,提到这个文件将在最新的EAP版本中得到修复,也就是下周可能修复. 所以如果小伙伴也遇到这个问题,那就再等等,也就是使用他们在的2018-09-20发布的EAP版本就好了. 如何调试vue文件在WebStorm/IntelliJ Idea 一份官方的介绍文档和github的仓库代码: https://github.com/JetBrains/webstorm-samples/tree/master/Vue 第二份参考文档: https://medium.com/@OlegVaraksin/debug-javascript-code-from-webstorm-or-intellij-idea-672edf922f78 官方文档如何操作实现Debugger功能 3.1 [https://blog.jetbrains.com/webstorm/2018/01/working-with-vue-js-in-webstorm/]](https://blog.jetbrains.com/webstorm/2018/01/working-with-vue-js-in-webstorm/ ) 3.2 https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000639410-Debuging-javascript-all-variables-are-undefined-Vue-Nuxt-Webpack","tags":"JavaScript","url":"articles/debug-vue/"},{"title":"IDEA 调优","text":"IDEA 运行缓慢 调优参考文档: https://blog.csdn.net/u013295276/article/details/78543190 问题解决思路: https://blog.csdn.net/zdxxinlang/article/details/78391060 推荐配置参数如下 - Xms2048m - Xmx2048m - Xverify :none - XX :+ DisableExplicitGC - XX : MetaspaceSize = 512 m - XX : ReservedCodeCacheSize = 240 m - XX :+ UseConcMarkSweepGC - XX : SoftRefLRUPolicyMSPerMB = 50 - ea - Dsun . io . useCanonCaches = false - Djava . net . preferIPv4Stack = true - XX :+ HeapDumpOnOutOfMemoryError - XX :- OmitStackTraceInFastThrow","tags":"Java","url":"articles/idea-performance/"},{"title":"vuejs中使用的一些重要技巧","text":"style中配置 background-color , background-image 变量 代码如下 <v-btn color= \"primary\" fab dark class= \"checkbtn\" :style= \"{ marginTop: '8%', height: '240px', width: '240px', backgroundColor: backgroundcolor, backgroundRepeat: 'no-repeat', backgroundPosition: 'center', backgroundSize: '180px auto', backgroundImage: 'url(' + backgroundimage + ')'}\" @ click.native= \"submitCheckin\" :disabled= \"AlreadyCheckin\" > {{ checkinContent }} </v-btn> export default { name: 'CheckingIn', data () { return { checkinContent: '', AlreadyCheckin: false, backgroundcolor: 'green', backgroundimage: require('../assets/img/finger.png'), checkinNote: '' } }, foreach 获得 index [].foreach((item,index)=>{ }) 同vue的for循环一致,比如下面的 <template v-for= \"(task,index) in tasks\" > </template> 匹配子字符串 /** * 匹配子字符串 * @param content * @param substr * @returns {boolean} */ const matchSubString = function ( content , substr ) { let foundSubStr = false const reg = new RegExp ( '.*' + substr + '.*' , 'g' ) if ( content . match ( reg )) { /* Match found */ foundSubStr = true } return foundSubStr }","tags":"JavaScript","url":"articles/vuejs-best-tips/"},{"title":"怎么放大缩小图片的尺寸和图片尺寸转换","text":"图片尺寸放大缩小网站推荐 这个网站可以放大缩小图片的尺寸,方便调节图片的大小尺寸,网站地址: resize images iloveimg图片尺寸放大缩小 图片大小压缩网站推荐 压缩图片(推荐)","tags":"Tools","url":"articles/how-resize-image/"},{"title":"千行代码入门Python(转载)","text":"作者：笑虎 链接：https:// zhuanlan.zhihu.com/p/22909144 代码如下: # _*_ coding: utf-8 _*_ \"\"\"类型和运算----类型和运算----类型和运算----类型和运算----类型和运算----类型和运算----类型和运算----类型和运算----类型和运算----类型和运算----类型和运算\"\"\" #-- 寻求帮助: dir ( obj ) # 简单的列出对象obj所包含的方法名称，返回一个字符串列表 help ( obj . func ) # 查询obj . func的具体介绍和用法 #-- 测试类型的三种方法，推荐第三种 if type ( L ) == type ([]) : print ( \"L is list\" ) if type ( L ) == list : print ( \"L is list\" ) if isinstance ( L , list ) : print ( \"L is list\" ) #-- Python数据类型：哈希类型、不可哈希类型 # 哈希类型，即在原地不能改变的变量类型，不可变类型。可利用hash函数查看其hash值，也可以作为字典的key \"数字类型：int, float, decimal.Decimal, fractions.Fraction, complex\" \"字符串类型：str, bytes\" \"元组：tuple\" \"冻结集合：frozenset\" \"布尔类型：True, False\" \"None\" # 不可hash类型：原地可变类型：list、dict和set。它们不可以作为字典的key。 #-- 数字常量 1234 , - 1234 , 0 , 999999999 # 整数 1.23 , 1. , 3.14e-10 , 4 E210 , 4.0e+210 # 浮点数 0o177 , 0x9ff , 0 X9FF , 0b101010 # 八进制、十六进制、二进制数字 3 + 4 j , 3.0 + 4.0 j , 3 J # 复数常量，也可以用complex ( real , image ) 来创建 hex ( I ), oct ( I ), bin ( I ) # 将十进制数转化为十六进制、八进制、二进制表示的\"字符串\" int ( string , base ) # 将字符串转化为整数，base为进制数 # 2. x中，有两种整数类型：一般整数（32位）和长整数（无穷精度）。可以用l或L结尾，迫使一般整数成为长整数 float ( 'inf' ), float ( '-inf' ), float ( 'nan' ) # 无穷大 , 无穷小 , 非数 #-- 数字的表达式操作符 yield x # 生成器函数发送协议 lambda args : expression # 生成匿名函数 x if y else z # 三元选择表达式 x and y , x or y , not x # 逻辑与、逻辑或、逻辑非 x in y , x not in y # 成员对象测试 x is y , x is not y # 对象实体测试 x < y , x<=y , x > y , x >= y , x == y , x ! = y # 大小比较，集合子集或超集值相等性操作符 1 < a < 3 # Python中允许连续比较 x | y , x&y , x&#94;y # 位或、位与、位异或 x<<y , x>>y # 位操作：x左移、右移y位 + , - , * , / , // , %, ** # 真除法、floor除法：返回不大于真除法结果的整数值、取余、幂运算 - x , + x , ~x # 一元减法、识别、按位求补（取反） x [ i ], x [ i : j : k ] # 索引、分片、调用 int ( 3.14 ), float ( 3 ) # 强制类型转换 #-- 整数可以利用bit_length函数测试所占的位数 a = 1 ; a . bit_length () # 1 a = 1024 ; a . bit_length () # 11 #-- repr和str显示格式的区别 \"\"\" repr格式：默认的交互模式回显，产生的结果看起来它们就像是代码。 str格式：打印语句，转化成一种对用户更加友好的格式。 \"\"\" #-- 数字相关的模块 # math模块 # Decimal模块 ：小数模块 import decimal from decimal import Decimal Decimal ( \"0.01\" ) + Decimal ( \"0.02\" ) # 返回Decimal ( \"0.03\" ) decimal . getcontext (). prec = 4 # 设置全局精度为4 即小数点后边4位 # Fraction模块 ：分数模块 from fractions import Fraction x = Fraction ( 4 , 6 ) # 分数类型 4 / 6 x = Fraction ( \"0.25\" ) # 分数类型 1 / 4 接收字符串类型的参数 #-- 集合set \"\"\" set是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素。 set支持union(联合), intersection(交), difference(差)和symmetric difference(对称差集)等数学运算。 set支持x in set, len(set), for x in set。 set不记录元素位置或者插入点, 因此不支持indexing, slicing, 或其它类序列的操作 \"\"\" s = set ([ 3 , 5 , 9 , 10 ]) # 创建一个数值集合，返回 { 3 , 5 , 9 , 10 } t = set ( \"Hello\" ) # 创建一个唯一字符的集合返回 {} a = t | s ; t . union ( s ) # t 和 s的并集 b = t & s ; t . intersection ( s ) # t 和 s的交集 c = t – s ; t . difference ( s ) # 求差集（项在t中 , 但不在s中） d = t &#94; s ; t . symmetric_difference ( s ) # 对称差集（项在t或s中 , 但不会同时出现在二者中） t . add ( 'x' ); t . remove ( 'H' ) # 增加/删除一个item s . update ([ 10 , 37 , 42 ]) # 利用 [......] 更新s集合 x in s , x not in s # 集合中是否存在某个值 s . issubset ( t ); s <= t # 测试是否 s 中的每一个元素都在 t 中 s . issuperset ( t ); s >= t # 测试是否 t 中的每一个元素都在 s 中 s . copy (); # 该功能与set ( s ) s . discard ( x ); # 删除s中x s . clear () # 清空s { x** 2 for x in [ 1 , 2 , 3 , 4 ]} # 集合解析，结果： { 16 , 1 , 4 , 9 } { x for x in 'spam' } # 集合解析，结果： { 'a' , 'p' , 's' , 'm' } S = frozenset ( range ( - 5 , 5 )) # 一个冻结 ( 不可变 ) 的含有 - 5 到4的个整型数的集合 #-- 集合frozenset，不可变对象 \"\"\" set是可变对象，即不存在hash值，不能作为字典的键值。同样的还有list等(tuple是可以作为字典key的) frozenset是不可变对象，即存在hash值，可作为字典的键值 frozenset对象没有add、remove等方法，但有union/intersection/difference等方法 \"\"\" a = set ([ 1 , 2 , 3 ]) b = set () b . add ( a ) # error : set是不可哈希类型 b . add ( frozenset ( a )) # ok，将set变为frozenset，可哈希 #-- 布尔类型bool type ( True ) # 返回 < class 'bool' > isinstance ( False , int ) # bool类型属于整型，所以返回True True == 1 ; True is 1 # 输出 ( True , False ) #-- 动态类型简介 \"\"\" 变量名通过引用，指向对象。 Python中的\"类型\"属于对象，而不是变量，每个对象都包含有头部信息，比如\" 类型标示符 \" \" 引用计数器 \"等 \"\"\" #共享引用及在原处修改：对于可变对象，要注意尽量不要共享引用！ #共享引用和相等测试： L = [ 1 ], M = [ 1 ], L is M # 返回False L = M = [ 1 , 2 , 3 ], L is M # 返回True，共享引用 #增强赋值和共享引用：普通+号会生成新的对象，而增强赋值+=会在原处修改 L = M = [ 1 , 2 ] L = L + [ 3 , 4 ] # L = [ 1 , 2 , 3 , 4 ], M = [ 1 , 2 ] L += [ 3 , 4 ] # L = [ 1 , 2 , 3 , 4 ], M = [ 1 , 2 , 3 , 4 ] #-- 常见字符串常量和表达式 S = '' # 空字符串 S = \"spam's\" # 双引号和单引号相同 S = \" s\\np\\ta\\x00m \" # 转义字符 S = \"\"\" spam \"\"\" # 三重引号字符串，一般用于函数说明 S = r'\\temp' # Raw字符串，不会进行转义，抑制转义 S = b'Spam' # Python3中的字节字符串 S = u'spam' # Python2.6中的Unicode字符串 s1+s2, s1*3, s[i], s[i:j], len(s) # 字符串操作 'a %s parrot' % 'kind' # 字符串格式化表达式 'a {1} {0} parrot'.format('kind', 'red')# 字符串格式化方法 for x in s: print(x) # 字符串迭代，成员关系 [x*2 for x in s] # 字符串列表解析 ','.join(['a', 'b', 'c']) # 字符串输出，结果：a,b,c #-- 内置str处理函数： str1 = \" stringobject \" str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title() # 全部大写，全部小写、大小写转换，首字母大写，每个单词的首字母都大写 str1.ljust(width) # 获取固定长度，左对齐，右边不够用空格补齐 str1.rjust(width) # 获取固定长度，右对齐，左边不够用空格补齐 str1.center(width) # 获取固定长度，中间对齐，两边不够用空格补齐 str1.zfill(width) # 获取固定长度，右对齐，左边不足用0补齐 str1.find('t',start,end) # 查找字符串，可以指定起始及结束位置搜索 str1.rfind('t') # 从右边开始查找字符串 str1.count('t') # 查找字符串出现的次数 #上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1 str1.replace('old','new') # 替换函数，替换old为new，参数中可以指定maxReplaceTimes，即替换指定次数的old为new str1.strip(); # 默认删除空白符 str1.strip('d'); # 删除str1字符串中开头、结尾处，位于 d 删除序列的字符 str1.lstrip(); str1.lstrip('d'); # 删除str1字符串中开头处，位于 d 删除序列的字符 str1.rstrip(); str1.rstrip('d') # 删除str1字符串中结尾处，位于 d 删除序列的字符 str1.startswith('start') # 是否以start开头 str1.endswith('end') # 是否以end结尾 str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper() # 判断字符串是否全为字符、数字、小写、大写 #-- 三重引号编写多行字符串块，并且在代码折行处嵌入换行字符\\n mantra = \"\"\" hello world hello python hello my friend \"\"\" # mantra为\"\"\" hello world \\n hello python \\n hello my friend \"\"\" #-- 索引和分片： S[0], S[len(S)–1], S[-1] # 索引 S[1:3], S[1:], S[:-1], S[1:10:2] # 分片，第三个参数指定步长，如`S[1:10:2]`是从1位到10位没隔2位获取一个字符。 #-- 字符串转换工具： int('42'), str(42) # 返回(42, '42') float('4.13'), str(4.13) # 返回(4.13, '4.13') ord('s'), chr(115) # 返回(115, 's') int('1001', 2) # 将字符串作为二进制数字，转化为数字，返回9 bin(13), oct(13), hex(13) # 将整数转化为二进制/八进制/十六进制字符串，返回('0b1101', '015', '0xd') #-- 另类字符串连接 name = \" wang \" \" hong \" # 单行，name = \" wanghong \" name = \" wang \" \\ \" hong \" # 多行，name = \" wanghong \" #-- Python中的字符串格式化实现1--字符串格式化表达式 \"\"\" 基于C语言的'print'模型，并且在大多数的现有的语言中使用。 通用结构： %[(name)][flag][width].[precision]typecode name : 在括号中引用期望字典的一项 flag：可以是 - | + | 空格（正数前加空白，负数前加-） | 数字0（零填充） width：整个最小域宽度 ( 使用*从值中取 ) precision ] ：给定包括在 . 后面的数字个数（即精度） ( 使用*从值中取 ) typecode： \"\"\" \" this is %d %s bird\" % (1, 'dead') # 一般的格式化表达式 \"%s---%s---%s\" % (42, 3.14, [1, 2, 3]) # 字符串输出：'42---3.14---[1, 2, 3]' \"%d...%6d...%-6d...%06d\" % (1234, 1234, 1234, 1234) # 对齐方式及填充：\"1234... 1234...1234 ...001234\" x = 1.23456789 \"%e | %f | %g\" % (x, x, x) # 对齐方式：\"1.234568e+00 | 1.234568 | 1.23457\" \"%6.2f*%-6.2f*%06.2f*%+6.2f\" % (x, x, x, x) # 对齐方式：' 1.23*1.23 *001.23* +1.23' \"%(name1)d---%(name2)s\" % {\"name1\":23, \"name2\":\"value2\"} # 基于字典的格式化表达式 \"%(name)s is %(age)d\" % vars() # vars()函数调用返回一个字典，包含了所有本函数调用时存在的变量 #-- Python中的字符串格式化实现2--字符串格式化调用方法 # 普通调用 \"{0}, {1} and {2}\" . format ( 'spam' , 'ham' , 'eggs' ) # 基于位置的调用 \"{motto} and {pork}\" . format ( motto = 'spam' , pork = 'ham' ) # 基于Key的调用 \"{motto} and {0}\" . format ( 'ham' , motto = 'spam' ) # 混合调用 # 添加键 属性 偏移量 ( import sys ) \"my {1[spam]} runs {0.platform}\" . format ( sys , { 'spam':'laptop' }) # 基于位置的键和属性 \"{config[spam]} {sys.platform}\" . format ( sys = sys , config = { 'spam':'laptop' }) # 基于Key的键和属性 \"first = {0[0]}, second = {0[1]}\" . format ([ 'A' , 'B' , 'C' ]) # 基于位置的偏移量 # 具体格式化 \"{0:e}, {1:.3e}, {2:g}\" . format ( 3.14159 , 3.14159 , 3.14159 ) # 输出'3.141590e+00, 3.142e+00, 3.14159' \"{fieldname:format_spec}\" . format (......) # 说明: \"\"\" fieldname是指定参数的一个数字或关键字, 后边可跟可选的\" . name \"或\" [ index ] \"成分引用 format_spec ::= [[fill]align][sign][#][0][width][][.precision][type] fill, ::= <any character> #填充字符 align ::= \" < \" | \" > \" | \" = \" | \" &#94; \" #对齐方式 sign ::= \" + \" | \" - \" | \" \" #符号说明 width ::= integer #字符串宽度 precision ::= integer #浮点数精度 type ::= \" b \" | \" c \" | \" d \" | \" e \" | \" E \" | \" f \" | \" F \" | \" g \" | \" G \" | \" n \" | \" o \" | \" s \" | \" x \" | \" X \" | \" %\" \"\"\" # 例子: '={0:10} = {1:10}'.format('spam', 123.456) # 输出'=spam = 123.456' '={0:>10}='.format('test') # 输出'= test=' '={0:<10}='.format('test') # 输出'=test =' '={0:&#94;10}='.format('test') # 输出'= test =' '{0:X}, {1:o}, {2:b}'.format(255, 255, 255) # 输出'FF, 377, 11111111' 'My name is {0:{1}}.'.format('Fred', 8) # 输出'My name is Fred .' 动态指定参数 #-- 常用列表常量和操作 L = [[1, 2], 'string', {}] # 嵌套列表 L = list('spam') # 列表初始化 L = list(range(0, 4)) # 列表初始化 list(map(ord, 'spam')) # 列表解析 len(L) # 求列表长度 L.count(value) # 求列表中某个值的个数 L.append(obj) # 向列表的尾部添加数据，比如append(2)，添加元素2 L.insert(index, obj) # 向列表的指定index位置添加数据，index及其之后的数据后移 L.extend(interable) # 通过添加iterable中的元素来扩展列表，比如extend([2])，添加元素2，注意和append的区别 L.index(value, [start, [stop]]) # 返回列表中值value的第一个索引 L.pop([index]) # 删除并返回index处的元素，默认为删除并返回最后一个元素 L.remove(value) # 删除列表中的value值，只删除第一次出现的value的值 L.reverse() # 反转列表 L.sort(cmp=None, key=None, reverse=False) # 排序列表 a = [1, 2, 3], b = a[10:] # 注意，这里不会引发IndexError异常，只会返回一个空的列表[] a = [], a += [1] # 这里实在原有列表的基础上进行操作，即列表的id没有改变 a = [], a = a + [1] # 这里最后的a要构建一个新的列表，即a的id发生了变化 #-- 用切片来删除序列的某一段 a = [1, 2, 3, 4, 5, 6, 7] a[1:4] = [] # a = [1, 5, 6, 7] a = [0, 1, 2, 3, 4, 5, 6, 7] del a[::2] # 去除偶数项(偶数索引的)，a = [1, 3, 5, 7] #-- 常用字典常量和操作 D = {} D = {'spam':2, 'tol':{'ham':1}} # 嵌套字典 D = dict.fromkeys(['s', 'd'], 8) # {'s': 8, 'd': 8} D = dict(name = 'tom', age = 12) # {'age': 12, 'name': 'tom'} D = dict([('name', 'tom'), ('age', 12)]) # {'age': 12, 'name': 'tom'} D = dict(zip(['name', 'age'], ['tom', 12])) # {'age': 12, 'name': 'tom'} D.keys(); D.values(); D.items() # 字典键、值以及键值对 D.get(key, default) # get函数 D.update(D_other) # 合并字典，如果存在相同的键值，D_other的数据会覆盖掉D的数据 D.pop(key, [D]) # 删除字典中键值为key的项，返回键值为key的值，如果不存在，返回默认值D，否则异常 D.popitem() # pop字典中随机的一项（一个键值对） D.setdefault(k[, d]) # 设置D中某一项的默认值。如果k存在，则返回D[k]，否则设置D[k]=d，同时返回D[k]。 del D # 删除字典 del D['key'] # 删除字典的某一项 if key in D: if key not in D: # 测试字典键是否存在 # 字典注意事项：（1）对新索引赋值会添加一项（2）字典键不一定非得是字符串，也可以为任何的不可变对象 # 不可变对象：调用对象自身的任意方法，也不会改变该对象自身的内容，这些方法会创建新的对象并返回。 # 字符串、整数、tuple都是不可变对象，dict、set、list都是可变对象 D[(1,2,3)] = 2 # tuple作为字典的key #-- 字典解析 D = {k:8 for k in ['s', 'd']} # {'s': 8, 'd': 8} D = {k:v for (k, v) in zip(['name', 'age'], ['tom', 12])} # {'age': 12, 'name': tom} #-- 字典的特殊方法__missing__：当查找找不到key时，会执行该方法 class Dict(dict): def __missing__(self, key): self[key] = [] return self[key] dct = Dict() dct[\" foo \"].append(1) # 这有点类似于collections.defalutdict dct[\" foo \"] # [1] #-- 元组和列表的唯一区别在于元组是不可变对象，列表时可变对象 a = [1, 2, 3] # a[1] = 0, OK a = (1, 2, 3) # a[1] = 0, Error a = ([1, 2]) # a[0][1] = 0, OK a = [(1, 2)] # a[0][1] = 0, Error #-- 元组的特殊语法: 逗号和圆括号 D = (12) # 此时D为一个整数 即D = 12 D = (12, ) # 此时D为一个元组 即D = (12, ) #-- 文件基本操作 output = open(r'C:\\spam', 'w') # 打开输出文件，用于写 input = open('data', 'r') # 打开输入文件，用于读。打开的方式可以为'w', 'r', 'a', 'wb', 'rb', 'ab'等 fp.read([size]) # size为读取的长度，以byte为单位 fp.readline([size]) # 读一行，如果定义了size，有可能返回的只是一行的一部分 fp.readlines([size]) # 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长。 fp.readable() # 是否可读 fp.write(str) # 把str写到文件中，write()并不会在str后加上一个换行符 fp.writelines(seq) # 把seq的内容全部写到文件中(多行一次性写入) fp.writeable() # 是否可写 fp.close() # 关闭文件。 fp.flush() # 把缓冲区的内容写入硬盘 fp.fileno() # 返回一个长整型的\"文件标签\" fp.isatty() # 文件是否是一个终端设备文件（unix系统中的） fp.tell() # 返回文件操作标记的当前位置，以文件的开头为原点 fp.next() # 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。 fp.seek(offset[,whence]) # 将文件打操作标记移到offset的位置。whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。 fp.seekable() # 是否可以seek fp.truncate([size]) # 把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。 for line in open('data'): print(line) # 使用for语句，比较适用于打开比较大的文件 open('f.txt', encoding = 'latin-1') # Python3.x Unicode文本文件 open('f.bin', 'rb') # Python3.x 二进制bytes文件 # 文件对象还有相应的属性：buffer closed encoding errors line_buffering name newlines等 #-- 其他 # Python中的真假值含义：1. 数字如果非零，则为真，0为假。 2. 其他对象如果非空，则为真 # 通常意义下的类型分类：1. 数字、序列、映射。 2. 可变类型和不可变类型 \"\"\" 语法和语句----语法和语句----语法和语句----语法和语句----语法和语句----语法和语句----语法和语句----语法和语句----语法和语句----语法和语句----语法和语句 \"\"\" #-- 赋值语句的形式 spam = 'spam' # 基本形式 spam, ham = 'spam', 'ham' # 元组赋值形式 [spam, ham] = ['s', 'h'] # 列表赋值形式 a, b, c, d = 'abcd' # 序列赋值形式 a, *b, c = 'spam' # 序列解包形式（Python3.x中才有） spam = ham = 'no' # 多目标赋值运算，涉及到共享引用 spam += 42 # 增强赋值，涉及到共享引用 #-- 序列赋值 序列解包 [a, b, c] = (1, 2, 3) # a = 1, b = 2, c = 3 a, b, c, d = \" spam \" # a = 's', b = 'p', c = 'a', d = 'm' a, b, c = range(3) # a = 0, b = 1, c = 2 a, *b = [1, 2, 3, 4] # a = 1, b = [2, 3, 4] *a, b = [1, 2, 3, 4] # a = [1, 2, 3], b = 4 a, *b, c = [1, 2, 3, 4] # a = 1, b = [2, 3], c = 4 # 带有*时 会优先匹配*之外的变量 如 a, *b, c = [1, 2] # a = 1, c = 2, b = [] #-- print函数原型 print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False) # 流的重定向 print('hello world') # 等于sys.stdout.write('hello world') temp = sys.stdout # 原有流的保存 sys.stdout = open('log.log', 'a') # 流的重定向 print('hello world') # 写入到文件log.log sys.stdout.close() sys.stdout = temp # 原有流的复原 #-- Python中and或or总是返回对象(左边的对象或右边的对象) 且具有短路求值的特性 1 or 2 or 3 # 返回 1 1 and 2 and 3 # 返回 3 #-- if/else三元表达符（if语句在行内） A = 1 if X else 2 A = 1 if X else (2 if Y else 3) # 也可以使用and-or语句（一条语句实现多个if-else） result = (a > 20 and \" big than 20 \" or a > 10 and \" big than 10 \" or a > 5 and \" big than 5 \") #-- Python的while语句或者for语句可以带else语句 当然也可以带continue/break/pass语句 while a > 1: anything else: anything # else语句会在循环结束后执行，除非在循环中执行了break，同样的还有for语句 for i in range(5): anything else: anything #-- for循环的元组赋值 for (a, b) in [(1, 2), (3, 4)]: # 最简单的赋值 for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: # 自动解包赋值 for ((a, b), c) in [((1, 2), 3), (\" XY \", 6)]: # 自动解包 a = X, b = Y, c = 6 for (a, *b) in [(1, 2, 3), (4, 5, 6)]: # 自动解包赋值 #-- 列表解析语法 M = [[1,2,3], [4,5,6], [7,8,9]] res = [sum(row) for row in M] # G = [6, 15, 24] 一般的列表解析 生成一个列表 res = [c * 2 for c in 'spam'] # ['ss', 'pp', 'aa', 'mm'] res = [a * b for a in [1, 2] for b in [4, 5]] # 多解析过程 返回[4, 5, 8, 10] res = [a for a in [1, 2, 3] if a < 2] # 带判断条件的解析过程 res = [a if a > 0 else 0 for a in [-1, 0, 1]] # 带判断条件的高级解析过程 # 两个列表同时解析：使用zip函数 for teama, teamb in zip([\" Packers \", \" 49 ers \"], [\" Ravens \", \" Patriots \"]): print(teama + \" vs . \" + teamb) # 带索引的列表解析：使用enumerate函数 for index, team in enumerate([\" Packers \", \" 49 ers \", \" Ravens \", \" Patriots \"]): print(index, team) # 输出0, Packers \\n 1, 49ers \\n ...... #-- 生成器表达式 G = (sum(row) for row in M) # 使用小括号可以创建所需结果的生成器generator object next(G), next(G), next(G) # 输出(6, 15, 24) G = {sum(row) for row in M} # G = {6, 15, 24} 解析语法还可以生成集合和字典 G = {i:sum(M[i]) for i in range(3)} # G = {0: 6, 1: 15, 2: 24} #-- 文档字符串:出现在Module的开端以及其中函数或类的开端 使用三重引号字符串 \"\"\" module document \"\"\" def func(): \"\"\" function document \"\"\" print() class Employee: \"\"\" class document \"\"\" print() print(func.__doc__) # 输出函数文档字符串 print(Employee.__doc__) # 输出类的文档字符串 #-- 命名惯例: \"\"\" 以单一下划线开头的变量名 ( _ X ) 不会被from module import*等语句导入 前后有两个下划线的变量名 ( __ X__ ) 是系统定义的变量名，对解释器有特殊意义 以两个下划线开头但不以下划线结尾的变量名 ( __ X ) 是类的本地 ( 私有 ) 变量 \"\"\" #-- 列表解析 in成员关系测试 map sorted zip enumerate内置函数等都使用了迭代协议 'first line' in open('test.txt') # in测试 返回True或False list(map(str.upper, open('t'))) # map内置函数 sorted(iter([2, 5, 8, 3, 1])) # sorted内置函数 list(zip([1, 2], [3, 4])) # zip内置函数 [(1, 3), (2, 4)] #-- del语句: 手动删除某个变量 del X #-- 获取列表的子表的方法: x = [1,2,3,4,5,6] x[:3] # 前3个[1,2,3] x[1:5] # 中间4个[2,3,4,5] x[-3:] # 最后3个[4,5,6] x[::2] # 奇数项[1,3,5] x[1::2] # 偶数项[2,4,6] #-- 手动迭代：iter和next L = [1, 2] I = iter(L) # I为L的迭代器 I.next() # 返回1 I.next() # 返回2 I.next() # Error:StopIteration #-- Python中的可迭代对象 \"\"\" 1. range迭代器 2. map、zip和filter迭代器 3. 字典视图迭代器：D . keys ()), D . items () 等 4. 文件类型 \"\"\" \"\"\" 函数语法规则----函数语法规则----函数语法规则----函数语法规则----函数语法规则----函数语法规则----函数语法规则----函数语法规则----函数语法规则----函数语法规则 \"\"\" #-- 函数相关的语句和表达式 myfunc('spam') # 函数调用 def myfunc(): # 函数定义 return None # 函数返回值 global a # 全局变量 nonlocal x # 在函数或其他作用域中使用外层（非全局）变量 yield x # 生成器函数返回 lambda # 匿名函数 #-- Python函数变量名解析:LEGB原则，即: \"\"\" local ( functin ) --> encloseing function locals --> global ( module ) --> build - in ( python ) 说明:以下边的函数maker为例 则相对于action而言 X为Local N为Encloseing \"\"\" #-- 嵌套函数举例:工厂函数 def maker(N): def action(X): return X ** N return action f = maker(2) # pass 2 to N f(3) # 9, pass 3 to X #-- 嵌套函数举例:lambda实例 def maker(N): action = (lambda X: X**N) return action f = maker(2) # pass 2 to N f(3) # 9, pass 3 to X #-- nonlocal和global语句的区别 # nonlocal应用于一个嵌套的函数的作用域中的一个名称 例如: start = 100 def tester(start): def nested(label): nonlocal start # 指定start为tester函数内的local变量 而不是global变量start print(label, start) start += 3 return nested # global为全局的变量 即def之外的变量 def tester(start): def nested(label): global start # 指定start为global变量start print(label, start) start += 3 return nested #-- 函数参数，不可变参数通过\"值\"传递，可变参数通过\"引用\"传递 def f(a, b, c): print(a, b, c) f(1, 2, 3) # 参数位置匹配 f(1, c = 3, b = 2) # 参数关键字匹配 def f(a, b=1, c=2): print(a, b, c) f(1) # 默认参数匹配 f(1, 2) # 默认参数匹配 f(a = 1, c = 3) # 关键字参数和默认参数的混合 # Keyword-Only参数:出现在*args之后 必须用关键字进行匹配 def keyOnly(a, *b, c): print('') # c就为keyword-only匹配 必须使用关键字c = value匹配 def keyOnly(a, *, b, c): ...... # b c为keyword-only匹配 必须使用关键字匹配 def keyOnly(a, *, b = 1): ...... # b有默认值 或者省略 或者使用关键字参数b = value #-- 可变参数匹配: * 和 ** def f(*args): print(args) # 在元组中收集不匹配的位置参数 f(1, 2, 3) # 输出(1, 2, 3) def f(**args): print(args) # 在字典中收集不匹配的关键字参数 f(a = 1, b = 2) # 输出{'a':1, 'b':2} def f(a, *b, **c): print(a, b, c) # 两者混合使用 f(1, 2, 3, x=4, y=5) # 输出1, (2, 3), {'x':4, 'y':5} #-- 函数调用时的参数解包: * 和 ** 分别解包元组和字典 func(1, *(2, 3)) <==> func(1, 2, 3) func(1, **{'c':3, 'b':2}) <==> func(1, b = 2, c = 3) func(1, *(2, 3), **{'c':3, 'b':2}) <==> func(1, 2, 3, b = 2, c = 3) #-- 函数属性:(自己定义的)函数可以添加属性 def func():..... func.count = 1 # 自定义函数添加属性 print.count = 1 # Error 内置函数不可以添加属性 #-- 函数注解: 编写在def头部行 主要用于说明参数范围、参数类型、返回值类型等 def func(a:'spam', b:(1, 10), c:float) -> int : print(a, b, c) func.__annotations__ # {'c':<class 'float'>, 'b':(1, 10), 'a':'spam', 'return':<class 'int'>} # 编写注解的同时 还是可以使用函数默认值 并且注解的位置位于=号的前边 def func(a:'spam'='a', b:(1, 10)=2, c:float=3) -> int : print(a, b, c) #-- 匿名函数:lambda f = lambda x, y, z : x + y + z # 普通匿名函数，使用方法f(1, 2, 3) f = lambda x = 1, y = 1: x + y # 带默认参数的lambda函数 def action(x): # 嵌套lambda函数 return (lambda y : x + y) f = lambda: a if xxx() else b # 无参数的lambda函数，使用方法f() #-- lambda函数与map filter reduce函数的结合 list(map((lambda x: x + 1), [1, 2, 3])) # [2, 3, 4] list(filter((lambda x: x > 0), range(-4, 5))) # [1, 2, 3, 4] functools.reduce((lambda x, y: x + y), [1, 2, 3]) # 6 functools.reduce((lambda x, y: x * y), [2, 3, 4]) # 24 #-- 生成器函数:yield VS return def gensquare(N): for i in range(N): yield i** 2 # 状态挂起 可以恢复到此时的状态 for i in gensquare(5): # 使用方法 print(i, end = ' ') # [0, 1, 4, 9, 16] x = gensquare(2) # x是一个生成对象 next(x) # 等同于x.__next__() 返回0 next(x) # 等同于x.__next__() 返回1 next(x) # 等同于x.__next__() 抛出异常StopIteration #-- 生成器表达式:小括号进行列表解析 G = (x ** 2 for x in range(3)) # 使用小括号可以创建所需结果的生成器generator object next(G), next(G), next(G) # 和上述中的生成器函数的返回值一致 #（1）生成器(生成器函数/生成器表达式)是单个迭代对象 G = (x ** 2 for x in range(4)) I1 = iter(G) # 这里实际上iter(G) = G next(I1) # 输出0 next(G) # 输出1 next(I1) # 输出4 #（2）生成器不保留迭代后的结果 gen = (i for i in range(4)) 2 in gen # 返回True 3 in gen # 返回True 1 in gen # 返回False，其实检测2的时候，1已经就不在生成器中了，即1已经被迭代过了，同理2、3也不在了 #-- 本地变量是静态检测的 X = 22 # 全局变量X的声明和定义 def test(): print(X) # 如果没有下一语句 则该句合法 打印全局变量X X = 88 # 这一语句使得上一语句非法 因为它使得X变成了本地变量 上一句变成了打印一个未定义的本地变量(局部变量) if False: # 即使这样的语句 也会把print语句视为非法语句 因为: X = 88 # Python会无视if语句而仍然声明了局部变量X def test(): # 改进 global X # 声明变量X为全局变量 print(X) # 打印全局变量X X = 88 # 改变全局变量X #-- 函数的默认值是在函数定义的时候实例化的 而不是在调用的时候 例子: def foo(numbers=[]): # 这里的[]是可变的 numbers.append(9) print(numbers) foo() # first time, like before, [9] foo() # second time, not like before, [9, 9] foo() # third time, not like before too, [9, 9, 9] # 改进: def foo(numbers=None): if numbers is None: numbers = [] numbers.append(9) print(numbers) # 另外一个例子 参数的默认值为不可变的: def foo(count=0): # 这里的0是数字, 是不可变的 count += 1 print(count) foo() # 输出1 foo() # 还是输出1 foo(3) # 输出4 foo() # 还是输出1 \"\"\" 函数例子----函数例子----函数例子----函数例子----函数例子----函数例子----函数例子----函数例子----函数例子----函数例子----函数例子----函数例子----函数例子 \"\"\" \"\"\" 数学运算类 \"\"\" abs(x) # 求绝对值，参数可以是整型，也可以是复数，若参数是复数，则返回复数的模 complex([real[, imag]]) # 创建一个复数 divmod(a, b) # 分别取商和余数，注意：整型、浮点型都可以 float([x]) # 将一个字符串或数转换为浮点数。如果无参数将返回0.0 int([x[, base]]) # 将一个字符串或浮点数转换为int类型，base表示进制 long([x[, base]]) # 将一个字符串或浮点数转换为long类型 pow(x, y) # 返回x的y次幂 range([start], stop[, step]) # 产生一个序列，默认从0开始 round(x[, n]) # 四舍五入 sum(iterable[, start]) # 对集合求和 oct(x) # 将一个数字转化为8进制字符串 hex(x) # 将一个数字转换为16进制字符串 chr(i) # 返回给定int类型对应的ASCII字符 unichr(i) # 返回给定int类型的unicode ord(c) # 返回ASCII字符对应的整数 bin(x) # 将整数x转换为二进制字符串 bool([x]) # 将x转换为Boolean类型 \"\"\" 集合类操作 \"\"\" basestring() # str和unicode的超类，不能直接调用，可以用作isinstance判断 format(value [, format_spec]) # 格式化输出字符串，格式化的参数顺序从0开始，如\"I am {0},I like {1}\" enumerate(sequence[, start=0]) # 返回一个可枚举的对象，注意它有第二个参数 iter(obj[, sentinel]) # 生成一个对象的迭代器，第二个参数表示分隔符 max(iterable[, args...][key]) # 返回集合中的最大值 min(iterable[, args...][key]) # 返回集合中的最小值 dict([arg]) # 创建数据字典 list([iterable]) # 将一个集合类转换为另外一个集合类 set() # set对象实例化 frozenset([iterable]) # 产生一个不可变的set tuple([iterable]) # 生成一个tuple类型 str([object]) # 转换为string类型 sorted(iterable[, cmp[, key[, reverse]]]) # 集合排序 L = [('b',2),('a',1),('c',3),('d',4)] sorted(L, key=lambda x: x[1]), reverse=True) # 使用Key参数和reverse参数 sorted(L, key=lambda x: (x[0], x[1])) # 使用key参数进行多条件排序，即如果x[0]相同，则比较x[1] \"\"\" 逻辑判断 \"\"\" all(iterable) # 集合中的元素都为真的时候为真，特别的，若为空串返回为True any(iterable) # 集合中的元素有一个为真的时候为真，特别的，若为空串返回为False cmp(x, y) # 如果x < y ,返回负数；x == y, 返回0；x > y,返回正数 \"\"\" IO操作 \"\"\" file(filename [, mode [, bufsize]]) # file类型的构造函数。 input([prompt]) # 获取用户输入，推荐使用raw_input，因为该函数将不会捕获用户的错误输入 raw_input([prompt]) # 设置输入，输入都是作为字符串处理 open(name[, mode[, buffering]]) # 打开文件，与file有什么不同？推荐使用open \"\"\" 其他 \"\"\" callable(object) # 检查对象object是否可调用 classmethod(func) # 用来说明这个func是个类方法 staticmethod(func) # 用来说明这个func为静态方法 dir([object]) # 不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。 help(obj) # 返回obj的帮助信息 eval(expression) # 计算表达式expression的值，并返回 exec(str) # 将str作为Python语句执行 execfile(filename) # 用法类似exec()，不同的是execfile的参数filename为文件名，而exec的参数为字符串。 filter(function, iterable) # 构造一个序列，等价于[item for item in iterable if function(item)]，function返回值为True或False的函数 list(filter(bool, range(-3, 4)))# 返回[-3, -2, -1, 1, 2, 3], 没有0 hasattr(object, name) # 判断对象object是否包含名为name的特性 getattr(object, name [, defalut]) # 获取一个类的属性 setattr(object, name, value) # 设置属性值 delattr(object, name) # 删除object对象名为name的属性 globals() # 返回一个描述当前全局符号表的字典 hash(object) # 如果对象object为哈希表类型，返回对象object的哈希值 id(object) # 返回对象的唯一标识，一串数字 isinstance(object, classinfo) # 判断object是否是class的实例 isinstance(1, int) # 判断是不是int类型 isinstance(1, (int, float)) # isinstance的第二个参数接受一个元组类型 issubclass(class, classinfo) # 判断class是否为classinfo的子类 locals() # 返回当前的变量列表 map(function, iterable, ...) # 遍历每个元素，执行function操作 list(map(abs, range(-3, 4))) # 返回[3, 2, 1, 0, 1, 2, 3] next(iterator[, default]) # 类似于iterator.next() property([fget[, fset[, fdel[, doc]]]]) # 属性访问的包装类，设置后可以通过c.x=value等来访问setter和getter reduce(function, iterable[, initializer]) # 合并操作，从第一个开始是前两个参数，然后是前两个的结果与第三个合并进行处理，以此类推 def add(x,y):return x + y reduce(add, range(1, 11)) # 返回55 (注:1+2+3+4+5+6+7+8+9+10 = 55) reduce(add, range(1, 11), 20) # 返回75 reload(module) # 重新加载模块 repr(object) # 将一个对象变幻为可打印的格式 slice(start, stop[, step]) # 产生分片对象 type(object) # 返回该object的类型 vars([object]) # 返回对象的变量名、变量值得字典 a = Class(); # Class为一个空类 a.name = 'qi', a.age = 9 vars(a) # {'name':'qi', 'age':9} zip([iterable, ...]) # 返回对应数组 list(zip([1, 2, 3], [4, 5, 6])) # [(1, 4), (2, 5), (3, 6)] a = [1, 2, 3], b = [\" a \", \" b \", \" c \"] z = zip(a, b) # 压缩：[(1, \" a \"), (2, \" b \"), (3, \" c \")] zip(*z) # 解压缩：[(1, 2, 3), (\" a \", \" b \", \" c \")] unicode(string, encoding, errors) # 将字符串string转化为unicode形式，string为encoded string。 \"\"\" 模块Moudle----模块Moudle----模块Moudle----模块Moudle----模块Moudle----模块Moudle----模块Moudle----模块Moudle----模块Moudle----模块Moudle----模块Moudle \"\"\" #-- Python模块搜索路径: \"\"\" ( 1 ) 程序的主目录 ( 2 ) PYTHONPATH目录 ( 3 ) 标准链接库目录 ( 4 ) 任何 . pth文件的内容 \"\"\" #-- 查看全部的模块搜索路径 import sys sys.path sys.argv # 获得脚本的参数 sys.builtin_module_names # 查找内建模块 sys.platform # 返回当前平台 出现如： \" win32 \" \" linux \" \" darwin \"等 sys.modules # 查找已导入的模块 sys.modules.keys() sys.stdout # stdout 和 stderr 都是类文件对象，但是它们都是只写的。它们都没有 read 方法，只有 write 方法 sys.stdout.write(\" hello \" ) sys . stderr sys . stdin #-- 模块的使用代码 import module1 , module2 # 导入module1 使用module1 . printer () from module1 import printer # 导入module1中的printer变量 使用printer () from module1 import * # 导入module1中的全部变量 使用不必添加module1前缀 #-- 重载模块reload: 这是一个内置函数 而不是一条语句 from imp import reload reload ( module ) #-- 模块的包导入:使用点号(.)而不是路径(dir1\\dir2)进行导入 import dir1 . dir2 . mod # d导入包 ( 目录 ) dir1中的包dir2中的mod模块 此时dir1必须在Python可搜索路径中 from dir1 . dir2 . mod import * # from语法的包导入 #-- __init__.py包文件:每个导入的包中都应该包含这么一个文件 \"\"\" 该文件可以为空 首次进行包导入时 该文件会自动执行 高级功能:在该文件中使用__all__列表来定义包(目录)以from*的形式导入时 需要导入什么 \"\"\" #-- 包相对导入:使用点号(.) 只能使用from语句 from . import spam # 导入当前目录下的spam模块（错误: 当前目录下的模块 , 直接导入即可） from . spam import name # 导入当前目录下的spam模块的name属性（错误: 当前目录下的模块 , 直接导入即可，不用加 . ） from .. import spam # 导入当前目录的父目录下的spam模块 #-- 包相对导入与普通导入的区别 from string import * # 这里导入的string模块为sys . path路径上的 而不是本目录下的string模块 ( 如果存在也不是 ) from . string import * # 这里导入的string模块为本目录下的 ( 不存在则导入失败 ) 而不是sys . path路径上的 #-- 模块数据隐藏:最小化from*的破坏 _ X # 变量名前加下划线可以防止from*导入时该变量名被复制出去 __ all__ = [ 'x' , 'x1' , 'x2' ] # 使用__all__列表指定from* 时复制出去的变量名 ( 变量名在列表中为字符串形式 ) #-- 可以使用__name__进行模块的单元测试:当模块为顶层执行文件时值为'__main__' 当模块被导入时为模块名 if __ name__ == '__main__': doSomething # 模块属性中还有其他属性，例如： __ doc__ # 模块的说明文档 __ file__ # 模块文件的文件名，包括全路径 __ name__ # 主文件或者被导入文件 __ package__ # 模块所在的包 #-- import语句from语句的as扩展 import modulename as name from modulename import attrname as name #-- 得到模块属性的几种方法 假设为了得到name属性的值 M . name M . __ dict__ [ 'name' ] sys . modules [ 'M' ]. name getattr ( M , 'name' ) \"\"\"类与面向对象----类与面向对象----类与面向对象----类与面向对象----类与面向对象----类与面向对象----类与面向对象----类与面向对象----类与面向对象----类与面向对象\"\"\" #-- 最普通的类 class C1 ( C2 , C3 ) : spam = 42 # 数据属性 def __ init__ ( self , name ) : # 函数属性:构造函数 self . name = name def __ del__ ( self ) : # 函数属性:析构函数 print ( \"goodbey \" , self . name ) I1 = C1 ( 'bob' ) #-- Python的类没有基于参数的函数重载 class FirstClass : def test ( self , string ) : print ( string ) def test ( self ) : # 此时类中只有一个test函数 即后者test ( self ) 它覆盖掉前者带参数的test函数 print ( \"hello world\" ) #-- 子类扩展超类: 尽量调用超类的方法 class Manager ( Person ) : def giveRaise ( self , percent , bonus = .10 ) : self . pay = int ( self . pay* ( 1 + percent + bonus )) # 不好的方式 复制粘贴超类代码 Person . giveRaise ( self , percent + bonus ) # 好的方式 尽量调用超类方法 #-- 类内省工具 bob = Person ( 'bob' ) bob . __ class__ # < class 'Person' > bob . __ class__ . __ name__ # 'Person' bob . __ dict__ # { 'pay': 0 , 'name':'bob' , 'job':'Manager' } #-- 返回1中 数据属性spam是属于类 而不是对象 I1 = C1 ( 'bob' ); I2 = C2 ( 'tom' ) # 此时I1和I2的spam都为42 但是都是返回的C1的spam属性 C1 . spam = 24 # 此时I1和I2的spam都为24 I1 . spam = 3 # 此时I1新增自有属性spam 值为2 I2和C1的spam还都为24 #-- 类方法调用的两种方式 instance . method ( arg ...) class . method ( instance , arg ...) #-- 抽象超类的实现方法 # ( 1 ) 某个函数中调用未定义的函数 子类中定义该函数 def delegate ( self ) : self . action () # 本类中不定义action函数 所以使用delegate函数时就会出错 # ( 2 ) 定义action函数 但是返回异常 def action ( self ) : raise NotImplementedError ( \"action must be defined\" ) # ( 3 ) 上述的两种方法还都可以定义实例对象 实际上可以利用@装饰器语法生成不能定义的抽象超类 from abc import ABCMeta , abstractmethod class Super ( metaclass = ABCMeta ) : @abstractmethod def action ( self ) : pass x = Super () # 返回 TypeError : Can 't instantiate abstract class Super with abstract methods action #-- # OOP和继承: \"is-a\"的关系 class A(B): pass a = A() isinstance(a, B) # 返回True, A是B的子类 a也是B的一种 # OOP和组合: \"has-a\"的关系 pass # OOP和委托: \"包装\"对象 在Python中委托通常是以\"__getattr__\"钩子方法实现的, 这个方法会拦截对不存在属性的读取 # 包装类(或者称为代理类)可以使用__getattr__把任意读取转发给被包装的对象 class wrapper: def __init__(self, object): self.wrapped = object def __getattr(self, attrname): print(' Trace : ', attrname) return getattr(self.wrapped, attrname) # 注:这里使用getattr(X, N)内置函数以变量名字符串N从包装对象X中取出属性 类似于X.__dict__[N] x = wrapper([1, 2, 3]) x.append(4) # 返回 \"Trace: append\" [1, 2, 3, 4] x = wrapper({'a':1, 'b':2}) list(x.keys()) # 返回 \"Trace: keys\" ['a', 'b'] #-- 类的伪私有属性:使用__attr class C1: def __init__(self, name): self.__name = name # 此时类的__name属性为伪私有属性 原理 它会自动变成self._C1__name = name def __str__(self): return 'self . name = %s' % self.__name I = C1 ( 'tom' ) print ( I ) # 返回 self . name = tom I . __ name = 'jeey' # 这里无法访问 __ name为伪私有属性 I . _ C1__name = 'jeey' # 这里可以修改成功 self . name = jeey #-- 类方法是对象:无绑定类方法对象 / 绑定实例方法对象 class Spam : def doit ( self , message ) : print ( message ) def selfless ( message ) print ( message ) obj = Spam () x = obj . doit # 类的绑定方法对象 实例 + 函数 x ( 'hello world' ) x = Spam . doit # 类的无绑定方法对象 类名 + 函数 x ( obj , 'hello world' ) x = Spam . selfless # 类的无绑定方法是函数 在3 .0 之前无效 x ( 'hello world' ) #-- 获取对象信息: 属性和方法 a = MyObject () dir ( a ) # 使用dir函数 hasattr ( a , 'x' ) # 测试是否有x属性或方法 即a . x是否已经存在 setattr ( a , 'y' , 19 ) # 设置属性或方法 等同于a . y = 19 getattr ( a , 'z' , 0 ) # 获取属性或方法 如果属性不存在 则返回默认值0 #这里有个小技巧，setattr可以设置一个不能访问到的属性，即只能用getattr获取 setattr ( a , \"can't touch\" , 100 ) # 这里的属性名带有空格，不能直接访问 getattr ( a , \"can't touch\" , 0 ) # 但是可以用getattr获取 #-- 为类动态绑定属性或方法: MethodType方法 # 一般创建了一个class的实例后 , 可以给该实例绑定任何属性和方法 , 这就是动态语言的灵活性 class Student ( object ) : pass s = Student () s . name = 'Michael' # 动态给实例绑定一个属性 def set_age ( self , age ) : # 定义一个函数作为实例方法 self . age = age from types import MethodType s . set_age = MethodType ( set_age , s ) # 给实例绑定一个方法 类的其他实例不受此影响 s . set_age ( 25 ) # 调用实例方法 Student . set_age = MethodType ( set_age , Student ) # 为类绑定一个方法 类的所有实例都拥有该方法 \"\"\"类的高级话题----类的高级话题----类的高级话题----类的高级话题----类的高级话题----类的高级话题----类的高级话题----类的高级话题----类的高级话题----类的高级话题\"\"\" #-- 多重继承: \"混合类\", 搜索方式\"从下到上 从左到右 广度优先\" class A ( B , C ) : pass #-- 类的继承和子类的初始化 # 1. 子类定义了__init__方法时，若未显示调用基类__init__方法，python不会帮你调用。 # 2. 子类未定义__init__方法时，python会自动帮你调用首个基类的__init__方法，注意是首个。 # 3. 子类显示调用基类的初始化函数： class FooParent ( object ) : def __ init__ ( self , a ) : self . parent = 'I\\'m the Parent . ' print(' Parent :a=' + str(a)) def bar(self, message): print(message + ' from Parent ') class FooChild(FooParent): def __init__(self, a): FooParent.__init__(self, a) print(' Child :a=' + str(a)) def bar(self, message): FooParent.bar(self, message) print(message + ' from Child ') fooChild = FooChild(10) fooChild.bar(' HelloWorld ') #-- #实例方法 / 静态方法 / 类方法 class Methods: def imeth(self, x): print(self, x) # 实例方法：传入的是实例和数据，操作的是实例的属性 def smeth(x): print(x) # 静态方法：只传入数据 不传入实例，操作的是类的属性而不是实例的属性 def cmeth(cls, x): print(cls, x) # 类方法：传入的是类对象和数据 smeth = staticmethod(smeth) # 调用内置函数，也可以使用@staticmethod cmeth = classmethod(cmeth) # 调用内置函数，也可以使用@classmethod obj = Methods() obj.imeth(1) # 实例方法调用 <__main__.Methods object...> 1 Methods.imeth(obj, 2) # <__main__.Methods object...> 2 Methods.smeth(3) # 静态方法调用 3 obj.smeth(4) # 这里可以使用实例进行调用 Methods.cmeth(5) # 类方法调用 <class ' __ main__ . Methods '> 5 obj.cmeth(6) # <class ' __ main__ . Methods '> 6 #-- 函数装饰器:是它后边的函数的运行时的声明 由@符号以及后边紧跟的\"元函数\"(metafunction)组成 @staticmethod def smeth(x): print(x) # 等同于: def smeth(x): print(x) smeth = staticmethod(smeth) # 同理 @classmethod def cmeth(cls, x): print(x) # 等同于 def cmeth(cls, x): print(x) cmeth = classmethod(cmeth) #-- 类修饰器:是它后边的类的运行时的声明 由@符号以及后边紧跟的\"元函数\"(metafunction)组成 def decorator(aClass):..... @decorator class C:.... # 等同于: class C:.... C = decorator(C) #-- 限制class属性: __slots__属性 class Student: __slots__ = ('name', 'age') # 限制Student及其实例只能拥有name和age属性 # __slots__属性只对当前类起作用, 对其子类不起作用 # __slots__属性能够节省内存 # __slots__属性可以为列表list，或者元组tuple #-- 类属性高级话题: @property # 假设定义了一个类:C，该类必须继承自object类，有一私有变量_x class C(object): def __init__(self): self.__x = None # 第一种使用属性的方法 def getx(self): return self.__x def setx(self, value): self.__x = value def delx(self): del self.__x x = property(getx, setx, delx, '') # property函数原型为property(fget=None,fset=None,fdel=None,doc=None) # 使用 c = C() c.x = 100 # 自动调用setx方法 y = c.x # 自动调用getx方法 del c.x # 自动调用delx方法 # 第二种方法使用属性的方法 @property def x(self): return self.__x @x.setter def x(self, value): self.__x = value @x.deleter def x(self): del self.__x # 使用 c = C() c.x = 100 # 自动调用setter方法 y = c.x # 自动调用x方法 del c.x # 自动调用deleter方法 #-- 定制类: 重写类的方法 # (1)__str__方法、__repr__方法: 定制类的输出字符串 # (2)__iter__方法、next方法: 定制类的可迭代性 class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def next(self): self.a, self.b = self.b, self.a + self.b if self.a > 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值 for n in Fib(): print(n) # 使用 # (3)__getitem__方法、__setitem__方法: 定制类的下标操作[] 或者切片操作slice class Indexer(object): def __init__(self): self.data = {} def __getitem__(self, n): # 定义getitem方法 print(' getitem : ', n) return self.data[n] def __setitem__(self, key, value): # 定义setitem方法 print(' setitem : key = { 0 }, value = { 1 } '.format(key, value)) self.data[key] = value test = Indexer() test[0] = 1; test[3] = ' 3 ' # 调用setitem方法 print(test[0]) # 调用getitem方法 # (4)__getattr__方法: 定制类的属性操作 class Student(object): def __getattr__(self, attr): # 定义当获取类的属性时的返回值 if attr=='age': return 25 # 当获取age属性时返回25 raise AttributeError('object has no attribute : %s' % attr) # 注意: 只有当属性不存在时 才会调用该方法 且该方法默认返回None 需要在函数最后引发异常 s = Student () s . age # s中age属性不存在 故调用__getattr__方法 返回25 # ( 5 ) __ call__方法: 定制类的'可调用'性 class Student ( object ) : def __ call__ ( self ) : # 也可以带参数 print ( 'Calling......' ) s = Student () s () # s变成了可调用的 也可以带参数 callable ( s ) # 测试s的可调用性 返回True # ( 6 ) __ len__方法：求类的长度 def __ len__ ( self ) : return len ( self . data ) #-- 动态创建类type() # 一般创建类 需要在代码中提前定义 class Hello ( object ) : def hello ( self , name='world' ) : print ( 'Hello, %s.' % name) h = Hello () h . hello () # Hello , world type ( Hello ) # Hello是一个type类型 返回 < class 'type' > type ( h ) # h是一个Hello类型 返回 < class 'Hello' > # 动态类型语言中 类可以动态创建 type函数可用于创建新类型 def fn ( self , name='world' ) : # 先定义函数 print ( 'Hello, %s.' % name) Hello = type ( 'Hello' , ( object ,), dict ( hello = fn )) # 创建Hello类 type原型: type ( name , bases , dict ) h = Hello () # 此时的h和上边的h一致 \"\"\"异常相关----异常相关----异常相关----异常相关----异常相关----异常相关----异常相关----异常相关----异常相关----异常相关----异常相关----异常相关----异常相关\"\"\" #-- #捕获异常: try : except : # 捕获所有的异常 等同于except Exception : except name : # 捕获指定的异常 except name , value : # 捕获指定的异常和额外的数据 ( 实例 ) except ( name1 , name2 ) : except ( name1 , name2 ), value : except name4 as X : else : # 如果没有发生异常 finally : # 总会执行的部分 # 引发异常: raise子句 ( raise IndexError ) raise < instance > # raise instance of a class , raise IndexError () raise < class > # make and raise instance of a class , raise IndexError raise # reraise the most recent exception #-- Python3.x中的异常链: raise exception from otherException except Exception as X : raise IndexError ( 'Bad' ) from X #-- assert子句: assert <test>, <data> assert x < 0 , 'x must be negative' #-- with/as环境管理器:作为常见的try/finally用法模式的替代方案 with expression [ as variable ], expression [ as variable ] : # 例子: with open ( 'test.txt' ) as myfile : for line in myfile : print ( line ) # 等同于: myfile = open ( 'test.txt' ) try : for line in myfile : print ( line ) finally : myfile . close () #-- 用户自定义异常: class Bad(Exception):..... \"\"\" Exception超类 / except基类即可捕获到其所有子类 Exception超类有默认的打印消息和状态 当然也可以定制打印显示: \"\"\" class MyBad ( Exception ) : def __ str__ ( self ) : return '定制的打印消息' try : MyBad () except MyBad as x : print ( x ) #-- 用户定制异常数据 class FormatError ( Exception ) : def __ init__ ( self , line , file ) : self . line = line self . file = file try : raise FormatError ( 42 , 'test.py' ) except FormatError as X : print ( 'Error at ' , X . file , X . line ) # 用户定制异常行为 ( 方法 ) :以记录日志为例 class FormatError ( Exception ) : logfile = 'formaterror.txt' def __ init__ ( self , line , file ) : self . line = line self . file = file def logger ( self ) : open ( self . logfile , 'a' ). write ( 'Error at ' , self . file , self . line ) try : raise FormatError ( 42 , 'test.py' ) except FormatError as X : X . logger () #-- 关于sys.exc_info:允许一个异常处理器获取对最近引发的异常的访问 try : ...... except : # 此时sys . exc_info () 返回一个元组 ( type , value , traceback ) # type : 正在处理的异常的异常类型 # value : 引发的异常的实例 # traceback : 堆栈信息 #-- 异常层次 BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- Warning \"\"\"Unicode和字节字符串---Unicode和字节字符串----Unicode和字节字符串----Unicode和字节字符串----Unicode和字节字符串----Unicode和字节字符串----Unicode和字节字符串\"\"\" #-- Python的字符串类型 \"\"\"Python2.x\"\"\" # 1. str表示8位文本和二进制数据 # 2. unicode表示宽字符Unicode文本 \"\"\"Python3.x\"\"\" # 1. str表示Unicode文本（8位或者更宽） # 2. bytes表示不可变的二进制数据 # 3. bytearray是一种可变的bytes类型 #-- 字符编码方法 \"\"\"ASCII\"\"\" # 一个字节，只包含英文字符，0到127，共128个字符，利用函数可以进行字符和数字的相互转换 ord ( 'a' ) # 字符a的ASCII码为97，所以这里返回97 chr ( 97 ) # 和上边的过程相反，返回字符'a' \"\"\"Latin-1\"\"\" # 一个字节，包含特殊字符，0到255，共256个字符，相当于对ASCII码的扩展 chr ( 196 ) # 返回一个特殊字符：Ä \"\"\"Unicode\"\"\" # 宽字符，一个字符包含多个字节，一般用于亚洲的字符集，比如中文有好几万字 \"\"\"UTF-8\"\"\" # 可变字节数，小于128的字符表示为单个字节，128到0X7FF之间的代码转换为两个字节，0X7FF以上的代码转换为3或4个字节 # 注意：可以看出来，ASCII码是Latin - 1 和UTF - 8 的一个子集 # 注意：utf - 8 是unicode的一种实现方式，unicode、gbk、gb2312是编码字符集 #-- 查看Python中的字符串编码名称，查看系统的编码 import encodings help ( encoding ) import sys sys . platform # 'win64' sys . getdefaultencoding () # 'utf-8' sys . getdefaultencoding () # 返回当前系统平台的编码类型 sys . getsizeof ( object ) # 返回object占有的bytes的大小 #-- 源文件字符集编码声明: 添加注释来指定想要的编码形式 从而改变默认值 注释必须出现在脚本的第一行或者第二行 \"\"\"说明：其实这里只会检查#和coding:utf-8，其余的字符都是为了美观加上的\"\"\" # _ * _ coding : utf - 8 _ * _ # coding = utf - 8 #-- #编码: 字符串 --> 原始字节 #解码: 原始字节 --> 字符串 #-- Python3.x中的字符串应用 s = '...' # 构建一个str对象，不可变对象 b = b'...' # 构建一个bytes对象，不可变对象 s [ 0 ], b [ 0 ] # 返回 ( '.' , 113 ) s [ 1 : ], b [ 1 : ] # 返回 ( '..' , b'..' ) B = B \"\"\" xxxx yyyy \"\"\" # B = b'\\nxxxx\\nyyyy\\n' # 编码，将str字符串转化为其raw bytes形式： str . encode ( encoding = 'utf-8' , errors = 'strict' ) bytes ( str , encoding ) # 编码例子： S = 'egg' S . encode () # b'egg' bytes ( S , encoding = 'ascii' ) # b'egg' # 解码，将raw bytes字符串转化为str形式： bytes . decode ( encoding = 'utf-8' , errors = 'strict' ) str ( bytes_or_buffer [, encoding [, errors ]]) # 解码例子： B = b'spam' B . decode () # 'spam' str ( B ) # \"b'spam'\" ，不带编码的str调用，结果为打印该bytes对象 str ( B , encoding = 'ascii' ) # 'spam'，带编码的str调用，结果为转化该bytes对象 #-- Python2.x的编码问题 u = u'汉' print repr ( u ) # u'\\xba\\xba' s = u . encode ( 'UTF-8' ) print repr ( s ) # '\\xc2\\xba\\xc2\\xba' u2 = s . decode ( 'UTF-8' ) print repr ( u2 ) # u'\\xba\\xba' # 对unicode进行解码是错误的 s2 = u . decode ( 'UTF-8' ) # UnicodeEncodeError : 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) # 同样，对str进行编码也是错误的 u2 = s.encode(' UTF - 8 ') # UnicodeDecodeError: 'ascii' codec can't decode byte 0xc2 in position 0 : ordinal not in range ( 128 ) #-- bytes对象 B = b'abc' B = bytes ( 'abc' , 'ascii' ) B = bytes ([ 97 , 98 , 99 ]) B = 'abc' . encode () # bytes对象的方法调用基本和str类型一致 但: B [ 0 ] 返回的是ASCII码值97 , 而不是b'a' #-- #文本文件: 根据Unicode编码来解释文件内容，要么是平台的默认编码，要么是指定的编码类型 # 二进制文件：表示字节值的整数的一个序列 open ( 'bin.txt' , 'rb' ) #-- Unicode文件 s = 'A\\xc4B\\xe8C' # s = 'A?BèC' len ( s ) = 5 #手动编码 l = s . encode ( 'latin-1' ) # l = b'A\\xc4B\\xe8C' len ( l ) = 5 u = s . encode ( 'utf-8' ) # u = b'A\\xc3\\x84B\\xc3\\xa8C' len ( u ) = 7 #文件输出编码 open ( 'latindata' , 'w' , encoding = 'latin-1' ). write ( s ) l = open ( 'latindata' , 'rb' ). read () # l = b'A\\xc4B\\xe8C' len ( l ) = 5 open ( 'uft8data' , 'w' , encoding = 'utf-8' ). write ( s ) u = open ( 'uft8data' , 'rb' ). read () # u = b'A\\xc3\\x84B\\xc3\\xa8C' len ( u ) = 7 #文件输入编码 s = open ( 'latindata' , 'r' , encoding = 'latin-1' ). read () # s = 'A?BèC' len ( s ) = 5 s = open ( 'latindata' , 'rb' ). read (). decode ( 'latin-1' ) # s = 'A?BèC' len ( s ) = 5 s = open ( 'utf8data' , 'r' , encoding = 'utf-8' ). read () # s = 'A?BèC' len ( s ) = 5 s = open ( 'utf8data' , 'rb' ). read (). decode ( 'utf-8' ) # s = 'A?BèC' len ( s ) = 5 \"\"\"其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他----其他\"\"\" #-- Python实现任意深度的赋值 例如a[0] = 'value1'; a[1][2] = 'value2'; a[3][4][5] = 'value3' class MyDict ( dict ) : def __ setitem__ ( self , key , value ) : # 该函数不做任何改动 这里只是为了输出 print ( 'setitem:' , key , value , self ) super (). __ setitem__ ( key , value ) def __ getitem__ ( self , item ) : # 主要技巧在该函数 print ( 'getitem:' , item , self ) # 输出信息 # 基本思路: a [ 1 ][ 2 ] 赋值时 需要先取出a [ 1 ] 然后给a [ 1 ] 的 [ 2 ] 赋值 if item not in self : # 如果a [ 1 ] 不存在 则需要新建一个dict 并使得a [ 1 ] = dict temp = MyDict () # 新建的dict: temp super (). __ setitem__ ( item , temp ) # 赋值a [ 1 ] = temp return temp # 返回temp 使得temp [ 2 ] = value有效 return super (). __ getitem__ ( item ) # 如果a [ 1 ] 存在 则直接返回a [ 1 ] # 例子: test = MyDict () test [ 0 ] = 'test' print ( test [ 0 ]) test [ 1 ][ 2 ] = 'test1' print ( test [ 1 ][ 2 ]) test [ 1 ][ 3 ] = 'test2' print ( test [ 1 ][ 3 ]) #-- Python中的多维数组 lists = [ 0 ] * 3 # 扩展list，结果为 [ 0 , 0 , 0 ] lists = [[]] * 3 # 多维数组，结果为 [[], [], []] ，但有问题，往下看 lists [ 0 ]. append ( 3 ) # 期望看到的结果 [[ 3 ], [], []] ，实际结果 [[ 3 ], [ 3 ], [ 3 ]] ，原因：list * n操作，是浅拷贝，如何避免？往下看 lists = [[] for i in range ( 3 )] # 多维数组，结果为 [[], [], []] lists [ 0 ]. append ( 3 ) # 结果为 [[ 3 ], [], []] lists [ 1 ]. append ( 6 ) # 结果为 [[ 3 ], [ 6 ], []] lists [ 2 ]. append ( 9 ) # 结果为 [[ 3 ], [ 6 ], [ 9 ]] lists = [[[] for j in range ( 4 )] for i in range ( 3 )] # 3 行4列，且每一个元素为 []","tags":"Python","url":"articles/1000-line-learn-python/"},{"title":"python中的urlencode与urldecode","text":"当url地址含有中文，或者参数有中文的时候，这个算是很正常了，但是把这样的url作为参数传递的时候（最常见的callback），需要把一些中文甚至'/'做一下编码转换。 所以对于一些中文或者字符，url不识别的，则需要进行转换，转换结果如下： 0x01 urlencode urllib库里面有个urlencode函数，可以把key-value这样的键值对转换成我们想要的格式，返回的是a=1&b=2这样的字符串，比如： import urllib.parse values = {} values [ 'username' ] = '02蔡彩虹' values [ 'password' ] = 'ddddd?' url = \"http://www.baidu.com\" data = urllib . parse . urlencode ( values ) print ( data ) 如果只想对一个字符串进行urlencode转换，怎么办？urllib提供另外一个函数：quote() import urllib.parse s = '长春' s = urllib . parse . quote ( s ) print ( s ) 0x02 urldecode 当urlencode之后的字符串传递过来之后，接受完毕就要解码了——urldecode。urllib提供了unquote()这个函数，可没有urldecode()！ s='%E5%B9%BF%E5%B7%9E' s=urllib.parse.unquote(s) print(s)","tags":"Python","url":"articles/urlencode-quote/"},{"title":"datetime时间模块有用的函数整理笔记","text":"ox01 毫秒时间戳转换成 datetime 时间对象 使用 datetime.fromtimestamp(seconds) 函数的时候需要注意: 1. 参数是秒不是毫秒 2. windows平台在Python 3.6版本的时候,如果时间在这个范围: 0 <= t <= 86399, 将会报 OSError: [Errno 22] Invalid argument ,这是一个已知的 bug ,目前已经在2018-07-27得到修复了. def microSeconds_to_Datetime ( unixTimestampMicroSeconds ): ''' fromtimestamp 对应的参数是秒,而大部分情况我们用的都是毫秒,所以这里需要转换下 :param unixTimestampMicroSeconds: 毫秒数 :return: datetime 对象 错误: https://bugs.python.org/issue29097 ,已经修复: 2018-07-27 datetime.fromtimestamp(t) when 0 <= t <= 86399 fails on Python 3.6 -> [Windows] datetime.fromtimestamp(t) when 0 <= t <= 86399 fails on Python 3.6 注意: OSError: [Errno 22] Invalid argument On Windows platform, this range can sometimes be restricted to years in 1970 through 2038. I have never seen this problem on a Linux system. 如果还是失败,尝试使用 fromutctimestamp 函数 ''' unixTimestampSeconds = unixTimestampMicroSeconds / 1000 newDate = datetime . datetime . fromtimestamp ( unixTimestampSeconds ) # otherStyleTime = time.strftime(\"%Y-%m-%d %H:%M:%S\", timearr) return newDate ox02 datetime 对象转换成毫秒时间戳 代码如下: def current_timeMicroSeconds (): # current_milli_time = lambda: int(round(time.time() * 1000)) totalSeconds = datetime . datetime . now () . timestamp () totalMicroSeconds = int ( totalSeconds * 1000 ) return totalMicroSeconds ox03 计算两个时间datetime对象的间隔 直接进行符号计算两个时间的间隔,使用 dir 发现有以下的几个属性,没有 毫秒 的属性注意: >>> dir(end - start) ['__abs__', '__add__', '__class__', '__delattr__', '__div__', '__doc__', '__eq__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__mul__', '__ne__', '__neg__', '__new__', '__nonzero__', '__pos__', '__radd__', '__rdiv__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rmul__', '__rsub__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', 'days', 'max', 'microseconds', 'min', 'resolution', 'seconds', 'total_seconds'] 所以一般使用如下几个方法: 1 diff.days # 间隔的天数 2. diff.seconds # 间隔的秒数 3. diff.microseconds # 间隔的秒数 所以函数如下: def compare_two_date(firstdate,seconddate): diff=seconddate-firstdate # totalSeconds=diff.microseconds totalSeconds=diff.seconds return totalSeconds","tags":"Python","url":"articles/time-module/"},{"title":"MySQL 语句级避免重复插入—— Insert Select Not Exist","text":"语法如下 --- 单条记录插入 INSERT INTO table(column1,column2,column3 ...columnN) SELECT value1,value2,value3 ...valueN FROM dual WHERE NOT EXISTS( SELECT * FROM table WHERE value = ? ); --- 多条记录插入 INSERT INTO table(column1,column2,column3 ...columnN) SELECT value1,value2,value3 ...valueN FROM anothertable WHERE NOT EXISTS( SELECT * FROM table WHERE value = ? ); 使用 dual 做表名可以让你在 select 语句后面直接跟上要插入字段的值，即使这些值还不存在当前表中","tags":"SQL","url":"articles/insert-prevent-duplicate/"},{"title":"Selenium3笔记-WebDriver源码初探","text":"Selenium3 有哪些变化？ 其实相对于与Selenium2，Selenium3没有做太多的改动。下面给出官方的文档说明，供参考。 参考文档：https://seleniumhq.wordpress.com/2013/08/28/the-road-to-selenium-3/ \"We aim for Selenium 3 to be \"a tool for user-focused automation of mobile and web apps\",Developers from projects such as Appium, ios-driver and selendroidwill be working on the suite of tests to enable this.\" \"Selenium 3 will see the removal of the original Selenium Core implementations, and consequently we'll be deprecating the RC APIs too，the original implementation will be available as a download, but it will no longer be actively developed once we release 3.0.\" 所以对于Selenium3来说最大的变动可能就是更加专注于手机和web的测试，尤其是手机的支持，因为你晓得的，现在更多的是移动的时代。 对于Selenium2中对于RemotControl的实现我看了下Selenium3的源码发现确实不在支持，而更多的转向了W3C standard，不是独成一套Selenium自己的WebDriver API .关于这个需要插如一下有关W3C WebDriver的知识。 有关W3C WebDriver 参考文档： https://www.w3.org/ TR /webdriver/，https://www.w3.org/testing/Activity，https://github.com/w3c/webdriver W3C组织制定了一套浏览器自动化的规范叫做WebDriver，这套规范规定了所有的浏览器生产商都必须遵守这个规范。其实定义了好多的遵循的接口和WebDriver的概念。对于Chrome，Firefox，Opera,Safari.etc他们都需要遵守这个规范并且实现规范里面的接口，这些实现一般都是伴随浏览器的开发进行的。 所以你应该明白了，Selenium不管是WebDriver还是RemoteWebDriver都是W3C WebDriver的一种实现而已。真正的核心浏览器的交互在对应的浏览器的WebDriver上，其实你有了对应的浏览器的WebDriver，参考W3C的标准接口文档HTTP-based wire protocol你就可以单独实现浏览器的操作。就是Client-Server的沟通。所有支持的命令列表如下： 举个ChromeDriver的例子。。。 首先我们找到ChromeDriver ，这个自然到chromium项目上去下载就好了。 https://sites.google.com/a/chromium.org/chromedriver/这里也有很多详细的接口的说明，这里的接口说明跟上面的W3C的接口说明差不多。你需要针对不同的浏览器下载对应的版本。下面我以下载的一个win版本的为例（下载地址：http://chromedriver.storage.googleapis.com/2.23/chromedriver_win32.zip ） WebDriver的使用 1.1 查看下chromedriver.exe提供给我们的一些可用的命令。 里面的使用很详细，这里我们只需要使用一个参数来启动ChromeDriver的server， –port ,命令如下：chromedriver.exe –port 9514，或者直接不输入端口直接回车，界面命令如下： 启动后chromedriver会在本地的9514端口号上进行监听通信，根据不同的命令发送到浏览器上，浏览器进行交互。比如启动一个chrome浏览器对应的命令是session，单独的ChromeDriver的HTTP通信URI是：http://localhost:9514/session,对于通过RemoteWebDriver的URL是：http://localhost:9514/wd/hub/session WebDriver -New Session 看一下这个说明： https://www.w3.org/ TR /webdriver/#dfn-new-session，操作流程如下： The remote end steps are: If the remote end is an intermediary node, take implementation-defined steps that either result in returning an error with error code session not created, or in returning a success with data that is isomorphic to that returned by remote ends according to the rest of this algorithm. If the maximum active sessions is equal to the length of the list of active sessions, return error with error code session not created. If there is a current user prompt, return error with error code session not created. Let capabilities be the result of getting a property named \"capabilities\" from the parameters argument. Let capabilities result be the result of processing capabilities with capabilities as an argument. If capabilities result is an error, return error with error code session not created. Let capabilities be capabilities result's data. Let session id be the result of generating a UUID. Let session be a new session with the session ID of session id. Set the current session to session. Append session to active sessions. 上面的流程已经在最新的Selenium WebDriver中实现了。所有启动一个浏览器做的session操作可以参考如下核心Selenium代码逻辑。 第一步设置chromeDriver的路径后面代码用到： System.setProperty(\"webdriver.chrome.driver\", \"chromedriver.exe\"); 第二步构建一个命令行对象用于执行chromedriver.exe的命令： org.openqa.selenium.remote.service.DriverService.Builder.build() public DS build() { if (port == 0) { port = PortProber.findFreePort(); //可用的端口号，例如232323,那么后面用到的命令就是:chromedriver.exe –port 232323 } if (exe == null) { exe = findDefaultExecutable(); } ImmutableList<String> args = createArgs(); return createDriverService(exe, port, args, environment); } ``` 1. 核心selenium命令执行类：`org.openqa.selenium.remote.RemoteWebDriver.RemoteWebDriver(CommandExecutor, Capabilities, Capabilities)` public RemoteWebDriver(CommandExecutor executor, Capabilities desiredCapabilities, Capabilities requiredCapabilities) { this.executor = executor; init(desiredCapabilities, requiredCapabilities); if (executor instanceof NeedsLocalLogs) { ((NeedsLocalLogs)executor).setLocalLogs(localLogs); } try { startClient(desiredCapabilities, requiredCapabilities); } catch (RuntimeException e) { try { stopClient(desiredCapabilities, requiredCapabilities); } catch (Exception ignored) { // Ignore the clean-up exception. We'll propagate the original failure. } throw e; } try { startSession(desiredCapabilities, requiredCapabilities); } catch (RuntimeException e) { try { quit(); } catch (Exception ignored) { // Ignore the clean-up exception. We'll propagate the original failure. } throw e; } } \" ` 以上的代码完成了如下的操作： 初始化desiredCapabilities对象，这是发送到客户端的JSON 数据， 启动一个session，这里包含一个判断，如果这是一个NEW_SESSION，那么会在上面构建的chromedriver上启动chromedriver然后在发送session命令。后台操作HTTP请求用到的是Apache HttpClient的API. 上面说明下WebDriver的通信是HTTP的协议，因此这里所有的通信都是通过JSON Wired进行沟通的RESTFul格式。也就是说所有的沟通都是一次RESTFul的request和response的过程。 参考如下Selenium的说明： https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol#command-summary JSON Request: JSON Response: 未完待续","tags":"SoftwareTesting","url":"articles/selenium-sourcecode/"},{"title":"Selenium得到当前页面的URL","text":"/** * getCurrentURL:(get the current page URL address). * @author huchan * @param driver --- the web driver instance * @return String ---the url of current page * @since JDK 1.6 */ public String getCurrentPageURL () { String pageurl=\"\" ; JavascriptExecutor je=(JavascriptExecutor) driver ; final String docstate=(String) je.executeScript(\"return document.readyState\") ; logger.info(\"Current loading page state is : \"+docstate); WebDriverWait wait=new WebDriverWait(driver,120); ExpectedCondition<Boolean> ec = new ExpectedCondition<Boolean>() { @Override public Boolean apply(WebDriver d) { return (docstate.equals(\" complete \")); } }; try{ logger.info(\" We just wait for the current page load correctly now ... \"); wait.until(ec); pageurl=driver.getCurrentUrl(); logger.info(\" we found the current url is : \"+pageurl); } catch(TimeoutException e){ pageurl=\" time out : 120 seconds \"; logger.error(\" Sorry the page cannot be loaded correctly : \" + e . getMessage () + driver . getCurrentUrl ()); } return pageurl ; } 不多说，代码如上。关键点是一定要等待页面加载完成了再使用driver.getCurrentUrl()方法，否则的话可能得到的页面URL 不正确。","tags":"SoftwareTesting","url":"articles/selenium-currenturl/"},{"title":"PL Developer 使用技巧整理","text":"Shortcut: Edit/Undo Ctrl+Z Edit/Redo Shift+Ctrl+Z Edit/PL/SQL Beautifier Ctrl+W (自定义) Shift+Home 选择光标位置到行首 Shift+End 选择光标位置到行尾 Ctrl+Shift+Home 选择光标位置到首行行首 Ctrl+Shift+End 选择光标位置到尾行行尾 Object:View Shift+Ctrl+V 查看 (自定义) Object:Describe Shift+Ctrl+D 结构 (自定义) Object:Properties Shift+Ctrl+P 属性 (自定义) Object:Browse Shift+Ctrl+B 浏览 (自定义) Object:Edit Data Shift+Ctrl+E 编辑数据(自定义) Object:Standard Query Shift+Ctrl+S 标准查询(自定义) Edit/Find Replace Ctrl+F Edit/Find Next Ctrl+L Edit/Find Previous Shift+Ctrl+L Edit/Replace Next Ctrl+P EDIT/Full Screen Ctrl+F11 Edit/Go to Line Ctrl+G Edit/Next Tab Page Ctrl+H Edit/Previous Tab Page Shift+Ctrl+H Session/Execute F8 Session/Break Shift+Esc Session/Commit F10 Session/Rollback Shift+F10 Debug/Toggle Breakpoint Ctrl+B Debug/Start F9 Debug/Run Ctrl+R Debug/Step Into Ctrl+N Debug/Step Over Ctrl+O Debug/Step Out Ctrl+T Tools/Explain Plan F5 Tools/Code Assistant F6 Editor: Start of Document Ctrl+PgUp OR Ctrl+Home Editor: End of Document Ctrl+PgDn OR Ctrl+End Editor: Delete Line Ctrl+Y Editor: Navigate Back Alt+Left Editor: Navigate Forward Alt+Right SQL Window: Previous SQL Ctrl+Up SQL Window: Next SQL Ctrl+Down PL / SQL Developer记住登陆密码 在使用PL/ SQL Developer时, 为了工作方便希望PL/ SQL Developer记住登录Oracle的用户名和密码; 设置方法: PL / SQL Developer->tools->Preferences->Oracle->Logon History, 在右边界面的\"Definition\"中,\"Store history\"是默认勾选的, 再勾选上\"Store with password\",即可. 上述方法若不好用,使用下面的方式: 在上面所说的界面中的\"Fixed Users\"中, 添加需要直接选择后就可登录的用户名/密码@ORACLE_SID, 如: cbsdb/cbsdb@cbsdb 重新登录的时候,从Oracle Logon的登录界面的Username后面的…按钮处, 选择需要登录的用户即可。 执行单条SQL语句( SQL Window中根据光标位置自动选择语句) 在使用PL/ SQL Developer的SQL Window时,按F8键, PL / SQL Developer默认是执行该窗口的所 有SQL语句,需要设置为鼠标所在的那条SQL语句,即执行当前SQL语句; 设置方法: PL / SQL Developer->tools->Preferences-> SQL Window->Window types, 勾上\"AutoSelect Statement\" 即可。 注意,每条语句后面要加分号。 格式化SQL语句 在使用PL/ SQL Developer的SQL Window时,有时候输入的SQL语句太长或太乱, 希望能用比较通用的写法格式话一下,这样看起来会好看些,也好分析; 使用方法: 选中需要格式化的SQL语句,然后点击工具栏的PL/ SQL beautifier按钮即可. 查看执行计划 在使用PL/ SQL Developer的SQL Window时,有时候输入的SQL语句执行的效率,分析下表结构, 如何可以提高查询的效率,可以通过查看Oracle提供的执行计划; 使用方法: 选中需要分析的SQL语句,然后点击工具栏的Explain plan按钮(即执行计划), 或者直接按F5即可。 调试存储过程 在使用PL/ SQL Developer操作Oracle时,有时候调用某些存储过程,或者调试存储过程; 调用存储过程的方法: 首先,在PL/ SQL Developer左边的Browser中选择Procedures, 查找需要调用的存储过程;然后,选中调试的存储过程,点击右键, 选择Test,在弹出来的Test script窗口中, 对于定义为in类型的参数,需要给该参数的Value输入值; 最后点击上面的条数按钮:Start debugger或者按F9; 最后点击:RUN或者Ctrl+R。 (具体要调式一个存储过程,请参照操作手册,这个大概说明下应用)。 oralce精简客户端的使用 要想PL/SQL连接oracle数据库,除了PL/ SQL Developer 之外还需要Oracle客户端, 有一个更方便的方法就是使用Oracle精简客户端,很多地方可以下载,文件很小,耗资源也少。 安装完成后修改安装目录下的\\Oracle\\ora90\\network\\ ADMIN \\tnsnames.ora文件: 格式如下: DATABASE_NAME = ( DESCRIPTION = (ADDRESS_LIST = ( ADDRESS = ( PROTOCOL = TCP )( HOST = 127.0.0.1)( PORT = 1521)) ) (CONNECT_DATA = #(SERVICE_NAME = dealer) ( SID = SID_NAME) #( SERVER = DEDICATED ) ) ) 关键字自动大写: 了解一点编程的常识的人都知道,编码风格很重要。 在阅读代码方面,保持一致的编码风格,阅读起来比较容易; 在执行效率方面,保持一致的编码风格,更有可能被放到共享SQL区中, 这样就提供了执行的效率。 另外,信息系统的核心是数据库,系统出问题时最先要查的就是SQL语句, 怎样在浩瀚的日志中快速找到那条SQL语句是件比较痛苦的事情。 SQL语句全部大写并不能彻底解决这一问题, 但在一堆代码中间找一行全部大写的字符相对容易些,你的眼睛会感谢你。 设置也很简单: Tools->Preferences->Editor,将Keyword case选择Uppercase。 我一般是让关键字大写,其他比如表名,字段名等都是小写。 大家都应该养成一种自己的编码习惯,并保持下去。 右键菜单 在PL/ SQL Developer(下面简称PLD)中的每一个文本编辑窗口, 如SQL Window,Command Window和Porgram Window, 右键点击某个对象名称,会弹出一个包含操作对象命令的菜单,我们这里称之为右键菜单。 对象类型可以是表,视图,同义词,存储过程和函数等。 根据对象类型的不同,弹出的菜单也有区别。 表和视图有View, Edit, Rename, Drop, Query data 和Edit data等功能。 View和Edit分别是查看和修改表的结构信息,如字段,主键,索引和约束等。 Query data相当于新打开一个窗口,并执行select * from 表。 Edit data相当于新打开一个窗口,并执行select * from 表 for update。 存储过程和函数有Test功能,选中后可以进入调试状态。 有时由于PLD识别错误,右键点击对象并不能出来正确的菜单, 可以在对象所在的DDL或DML语句的前面,加上分号,这样PLD就能正确的判断出对象的类型 Select for Update 有时我们需要把一些数据导入数据库中,如果用UE拼Insert语句,会比较麻烦,而且操作性不强。 PLD的SQL Window可以查询,新增,修改和删除表的内容。 查询自不必说,而新增,删除和修改,只需在select语句后加入for update, 对表进行行级锁定,然后点击窗口的锁型图标,即可进入编辑状态。 下面介绍一下如何从Excel中提取文本插入到数据库中, 我们的Excel文件中有三列,在数据库中建立临时表: CREATE TABLE t1( cino varchar2(100), contno varchar2(100), loanno varchar2(100) ) 然后在SQL Window中输入select t1 for update,并点击锁型鼠标,进入编辑状态, 用鼠标点击第一行的输入窗口,这时PLD会死锁几秒钟, 然后可以见到光标在第一行的输入框中闪动, 用鼠标把CINO, CONTNO , LOANNO选中,进入Excel中,把需要插入数据库的内容选中, 然后切换到PLD,按Ctrl + V,点击√,然后再点击Commit按钮, 则数据提交到表t1中,执行select * from t1可以看到内容. PL / SQL Beautifier( PL / SQL 美化器) PLD 6以上版本有对DML代码格式化的功能。 在SQL Window或Program Window中选中部分代码(如果不选则对整个窗口的代码操作), 在菜单中选Edit -> PL / SQL Beautifier,得到格式化的代码。 对于非法的DML语句或DDL语句,PLD将会在下方状态栏提示: PL / SQL Beautifier could not parse text。 在缺省的状态下,PLD会把DML语句的每一个字段都排在单独的一行,这样不方便查看。 在菜单中选Edit à PL / SQL Beautifier Options,进入Preferences窗口, 选择Edit,进入配置文件编辑界面,在标签栏选DML, 在窗口中部的Select, Insert和Update组框中把Fit选中,然后点击Save, 把配置文件保存到PLD的安装目录下,点击Close关闭。 在Rules file中输入配置文件所在位置,点击OK,完成配置文件切换。 这时再对代码进行格式化,就可以使每一个字段尽可能的在一行上了。 TNS Names 菜单Help->Support Info-> TNS Names,可以查看Oracle的tnsnames.ora。 Copy to Excel 在SQL Window中执行Select语句,在结果出来以后,右键点击下面的数据区, 选择Copy to Excel,可以把数据区的记录原样拷贝到Excel中。 但有两点需要注意: (1) field中不能以=开始,否则Excel会误认为是函数; (2) 数字不要超过17位,否则后面的位数将会置为0, 但可以通过在数字前加'来使Excel认为该field是文本, 同时对于数据库中Numbe类型的字段,最好用to_char输出,不然可能会显示不正常; 保持上次打开的SQL脚本 重新进入PL/ SQL Developer时,Window List能打开上次退出时的文档: (1) 将菜单Tools->Window list选项勾上; (2) Tools->Perferences->User Interface->Options的右边, 将\"Autosave desktop\"勾选. (3) 退出PL/ SQL Developer重新进入. 快速找到已知表名的表或其他对象: 在Tools菜单中,勾选上Object Browser,将对象浏览器打开, 双击对象浏览器中的某个对象所处的文件夹, 比如表都是在Tables文件夹中, 然后以尽快的速度输入表名,即可找到以你输入的几个字母开头的对象了. 快速关闭打开于Windows List中的文档窗口: 按住Shift键,左键点击需要关闭的文档窗口. PL / SQL DEVELOPER中的专用复制(Special Copy) 如果你正在用 PL / SQL Developer 写 SQL 和 PL / SQL 代码, 随后你又要在其它工具里使用代码,例如象 3GL 这样的程序设计语言, 那么你可能需要把这些代码转换为稍微不同的格式。 让我们假设你已经在 PL / SQL Developer 里写了并测试了这样一个SQL 语句: select deptno, sum(sal) mgr_sal from emp where job = ‘ MANAGER ' group by deptno order by mgr_sal desc 例如,如果你要在Borland Delphi 里使用这个语句,你可能需要象这样的格式: SQL := ‘select deptno, sum(sal) mgr_sal from emp' + #13#10 + ‘where job = ‘' MANAGER '‘' + #13#10 + ‘group by deptno' + #13#10 + ‘order by mgr_sal desc'; 为了这个目的,在PL/ SQL DEVELOPER中选中已写好的SQL语句,鼠标右键, 在弹出的菜单中找到 Special Copy。这个功能有一个子菜单,它显示了所有被定义的专用复制格式。 在选择了格式之后,被转换的代码就被储存在剪贴板上了, 这样你就可以粘贴它到相应工具的编辑器里了。 专用复制格式被定义在 PL / SQL Developer 安装目录下的 SpecialCopy 子目录里。 你可以改变预先确定的复制格式或者添加新的复制格式。 仅仅简单地添加一个带有 .copy 扩展名的文本文件就可以了, 它包含了一个针对 PL / SQL 代码第一行的变量 ( )、一个针对 PL / SQL 代码最后一行的变量( ) 和一个针对所有其它行的变量( )。下面是一个针对 Borland Delphi 的例子: ;PL/SQL Developer SpecialCopy definition for Borland Delphi ;<line_1> for first line ;<line_*> for all other lines ;<line_N> for last line ; SQL := '<line_1>' + #13#10 + '<line_*>' + #13#10 + '<line_n>'; 第一行需要为指派到 SQL 的变量加上前言,接下来需要有一个 CR / LF 对。 最后一行不需要有CR/ LF 对,但需要用分号来终止。所有其它行仅仅需要 CR / LF 接在后面。 如果 和 都与 一样,你可以忽略它们。 在一些语言里,你需要对特定的字符使用换码序列。 例如,在 C++ 里,你要对 tab字符( ASCII 码为 9)使用 \\t 。 要定义这些换码序列,请使用 #define 关键词: #define char(9) = \\t #define \\ = \\\\ String(\"<line_1>\\n\") + String(\"<line_*>\\n\") + String(\"<line_n>\"); 你还可以使用 \"#define compress\"来指出你要从结果里移除所有多余的空字符(空格、制表符和换行)。 注意,.copy 文件的名字将被包括在菜单里,所以你应该使用描述性的文件名。 在PL/ SQL DEVELOPER中复制行记录的简便方法 (1) 单击要拷贝的行记录左边的黑色小三角,该行被选中,右键复制。 (2) 粘贴至记事本里,然后复制刚才粘贴的内容。(该步骤不知何故不能缺) (3) 单击新记录左边的黑色小三角,右键粘贴即可。 快捷键定义的位置: Tools->Preferences->User Interface->Key configuration 选中需要定义的Item,然后按一个快捷键组合即可, 如果所按的快捷键已有定义,会有提示,这时候Cancel,另外选择快捷键组合即可; 通常情况下,打开PLSQL Developer后,最经常干的事就是打开SQL Window和Command Window, 就给这两个操作定义了快捷键, ALT +S 和 ALT + C,这样拿鼠标点三下的事情只需要按一下键。 设置方法: 菜单Tools -> Preferences -> Key Configuration 注意: 如果设置了快捷键不起作用, 回到Tools -> Preferences -> Key Configuration界面, 点击最上方的\"Default Administrator\"右边的\"…\"按钮, 在弹出的\"Preference Set\"界面中,对\"Personal Preferences\" 以及下面的\"Definition\"->\"Description\"进行一下设置. 在窗口标题栏内显示文件的完全路径 Tools->Preferences->User Interface->Options 勾选\"Show complete file path in windows titles\" Object Brower中自定义Object的顺序以及登录后默认自动选中My Objects 默认情况下, PL / SQL Developer登录后,Brower里会选择All objects, 如果你登录的用户是dba,要展开tables目录,正常情况都需要Wait几秒钟, 而选择My Objects后响应速率则是以毫秒计算的。 设置方法: Tools菜单 -> Object Brower Filters,会打开Define Browser Filters界面, 选中\"My Objects\",并勾选 \"Default\" 设为默认即可。 Tools菜单 -> Object Brower Folders,会打开Define Browser Folders界面, 这里可以把经常用到的几个目录(比如:Tables Views Seq Functions Procedures) 移得靠上一点,并加上颜色区分,这样你的平均寻表时间会大大缩短,试试看。 双击即显示表数据 鼠标双击表或者视图时的默认响应实在让我感到失望,因为我最关心的是表结构和数据, 但是双击后这两件事情都没有发生,也许默认响应是高手们需要的, 但对我来说查看数据和表结构是最主要的,其他的我不关心。 不过好的是这是可以设置的,你可以给鼠标双击和拖放绑定需要的事件, 比如:双击编辑数据,拖放显示表结构,Yeah！ 设置方法: 菜单Tools -> Preferences -> Object Browser, 在右侧,为不同的Object Type绑定双击和拖放操作。 去掉注释的斜体样式: 菜单Tools -> Preferences -> User Interface->Editor 在右边的界面中\"Syntax Highlighting\"下,去掉\"Comment\"右边的\"Italic\"的勾选.","tags":"Java","url":"articles/pldeveloper-tips/"},{"title":"\" ORA -28547：connection to server failed,probable Oracle Net admin error\"的解决步骤（navicat,toad,plsql developer工具通用）","text":"错误 连接oracle 11g突然蹦出了一个错误\" ORA -28547：connection to server failed,probable Oracle Net admin error \"，见下图，我勒个去，真是郁闷死了，无奈在网上搜索了好久找到了解决方法，写下来了以便以后参考。 1. 第一个方法解决方案 listener.ora是服务器端的配置oracle的文件。 后来将listener.ora的这一行注释掉，就行了，， ( PROGRAM = extproc) 修改为： SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = prod) (ORACLE_HOME = /u01/app/oracle/product/10.2.0/db_1) # (PROGRAM = extproc) ) ) LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.8)(PORT = 1522)) (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC0)) ) ) 第二种解决方案 参考文章： https://forums.oracle.com/forums/message.jspa?messageID=693607 整理如下： 客户端的配置文件sqlnet.ora中配置如下： 将 #SQLNET.AUTHENTICATION_SERVICES= (NTS) 注释掉，改成如下即可！ 如下: SQLNET.AUTHENTICATION_SERVICES= (NONE) 同时修改监听器配置文件，具体做法是： 在oracle安装目录下搜索listener.ora文件，一般在$/ NETWORK /ADMIN目录下，把主机名用ip地址代替，例如( ADDRESS = ( PROTOCOL = TCP )( HOST = HBONLINE1 )( PORT = 1523))改为( ADDRESS = ( PROTOCOL = TCP )( HOST = 168.168.168.42)( PORT = 1523))。 第三种解决方案 如果你以上使用的是plsql developer工具或者是toad工具，应该以上的操作就绝对可以解决你的问题， 但是如果你使用的是navicat工具，以上怕是还不能解决你的问题。具体的如果在navicat工具上使用就是如下的问题： Oracle基本是默认安装，安装过程没出现过任何异常 Oracle开启了两个服务：OracleServiceORCL和OracleOraDb11g_home1TNSListener Navicat一直都连接不上本地的Oracle 网上搜了一大堆资料，大都是改那3个配置文件的 最终还是没能解决这个问题 最终的问题是： Navicat主机那里如果填本机IP地址（192.168.18.8），错误代码是： ORA -12541： TNS ：no listener 如果填localhost，错误代码是： ORA -28547：connection to server failed，probable Oracle Net admin error tnsping localhost 是通的，tnsping 192.168.18.8 则出错 TNS -12541: TNS : 无监听程序 解决的方案是： oci.dll的版本不对 从 http://www.oracle.com/technology/software/tech/oci/instantclient/index.html 下载client. 里面很多，根据你的版本来下，我下载的是instantclient_11_1。 在navicat的 工具-选项-其他- OCI ,选择刚下的client中的 oci.dll 设置环境变量： 1)在环境变量PATH中开头增加C:\\Instantclient10_2; 2)增加用户环境变量SQLPATH，值为C:\\Instantclient10_2 3)增加用户环境变量NLS_LANG，值为AMERICAN_AMERICA. UTF8 选择 Basic 连接，就大概能连接上了 以上的操作可以通过如下进行查找： 1、首先确认你的数据库已经启动了，可以用net start OracleServiceORCL 2、其次确认你的侦听启动了否，用lsnrctl status查看，如果没有启动，用lsnrctl start启动. 3、以上启动后，直接打开sqlplus，输入用户名密码，无需输入服务名，直接登录即可。","tags":"Java","url":"articles/oracle-ora-28547/"},{"title":"Oracle中的decode的使用","text":"Oracle 中 decode 函数用法 含义解释 decode(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值) 该函数的含义如下： IF 条件=值1 THEN RETURN(翻译值1) ELSIF 条件=值2 THEN RETURN(翻译值2) ...... ELSIF 条件=值n THEN RETURN(翻译值n) ELSE RETURN(缺省值) END IF decode(字段或字段的运算，值1，值2，值3） 这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回值3 当然值1，值2，值3也可以是表达式，这个函数使得某些sql语句简单了许多 使用方法 1、 比较大小 select decode(sign(变量1-变量2),-1,变量1,变量2) from dual; --取较小值 sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1 例如： 变量1=10，变量2=20 则sign(变量1-变量2)返回-1，decode解码结果为\"变量1\"，达到了取较小值的目的。 2、 此函数用在SQL语句中，功能介绍如下： Decode函数与一系列嵌套的 IF - THEN -ELSE语句相似。base_exp与compare1,compare2等等依次进行比较。如果base_exp和 第i 个compare项匹配，就返回第i 个对应的value 。如果base_exp与任何的compare值都不匹配，则返回default。每个compare值顺次求值，如果发现一个匹配，则剩下的compare值（如果还有的话）就都不再求值。一个为NULL的base_exp被认为和NULL compare值等价。如果需要的话，每一个compare值都被转换成和第一个compare 值相同的数据类型，这个数据类型也是返回值的类型。 Decode函数在实际开发中非常的有用 结合Lpad函数，如何使主键的值自动加1并在前面补0 select LPAD(decode(count(记录编号),0,1,max(to_number(记录编号)+1)),14,'0') 记录编号 from tetdmis select decode(dir,1,0,1) from a1_interval dir 的值是1变为0，是0则变为1 比如我要查询某班男生和女生的数量分别是多少? 通常我们这么写: select count(*) from 表 where 性别 ＝ 男； select count(*) from 表 where 性别 ＝ 女； 要想显示到一起还要union一下，太麻烦了 用decode呢，只需要一句话 select decode(性别，男，1，0），decode(性别，女，1，0） from 表 3、order by对字符列进行特定的排序 大家还可以在Order by中使用Decode。 例：表table_subject，有subject_name列。要求按照：语、数、外的顺序进行排序。这时，就可以非常轻松的使用Decode完成要求了。 select * from table_subject order by decode(subject_name, '语文', 1, '数学', 2, , '外语',3)","tags":"Java","url":"articles/oracle-decode/"},{"title":"mybatis connection error Cannot create PoolableConnectionFactory (Access denied for user ‘root ‘@'local","text":"异常错误 org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: ### Error querying database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Access denied for user 'root '@'localhost' (using password: YES)) ### The error may exist in com/sample/mappers/EmployeeMapper.xml ### The error may involve com.sample.dao.EmployeeDao.listall ### The error occurred while executing a query ### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is org.apache.commons.dbcp.SQLNestedException: Cannot create PoolableConnectionFactory (Access denied for user 'root '@'localhost' (using password: YES)) 解决方法 这个问题大致就是需要检查你的数据源配置即Resource中的：url,username,password url这个一般是\"jdbc:mysql://localhost:3306/test\",一定要注意3306，这个是你数据库连接用的端口,可以把它改成别的，但是如果你用的tomcat容器，别把它写成8080，这样就会产生Cannot create PoolableConnectionFactory (Communications link failure问题，还有就是url=jdbc:mysql://localhost:3306/test中的localhost，也不是随便配置的，要看你的数据库中的from host 我当时实在MySql Workbench5.2 CE中的 Users and Privileges中，有个Server Access Management User From Host 你看From Host中有没有localhost，如果有你就能写成url=jdbc:mysql://localhost:3306/test，要是from host有127.0.0.1的话，也可以写成url=jdbc:mysql://127.0.0.1:3306/test 还有就是 username= 这个一定要写正确，我当时写的是name= ，结果mysql找不到username，然后他自动把username设为\"\"，以至于错误提示： java.sql.SQLException: Access denied for user ‘' @'localhost' (using password: YES ) 你看到@前面是两个单引号了吗，那就是我没输入username而导致默认的默认username，其实这个错误也可以用设置权限改，但是那是mysql内容，就不说了。 总结起来就是：url端口要写对，不能写其他程序被占用的，127.0.01还是localhost要看数据库里面有哪个，还要就是把对的驱动放入项目中的WEB- INF /lib里，这里提一下不用再放到tomcat的lib中。","tags":"Java","url":"articles/mybatis-poolableconnectionfactory/"},{"title":"VirtualBox安装苹果虚拟机镜像MacOS 10.13/10.14 Beta6(2018-09-05更新)","text":"准备工作 测试时间: 2018.09.05 VirtualBox版本: 5.2.18 MacOS镜像版本：MacOS High Sierra 10.13 下载地址: https://blog.csdn.net/icarus666/article/details/79536388 中下载的镜像 网盘下载: macOS High Sierra 10.13.iso MacOS vmdk镜像版本: MacOS Mojave 10.14 Beta 6 百度网盘下载地址: 百度网盘 Mac OS 10.14 Beta6 ,密码：ni2b Google Driver下载地址: Google Driver for Mac 10.14 Beta6 测试结果: VirtualBox中 成功安装MacOS 10.13/10.14 Beta 6 参考地址 MacOS 10.14 beta 6安装步骤博客,更新日期 2018-09-04( 推荐 ) MacOS 10.13.6安装步骤博客,更新日期 2018-09-04 MacOS 10.13安装步骤博客 MacOS 10.13镜像下载地址 Cordova安装配置 创建Mac OS虚拟机镜像 在VirtualBox中新建一个虚拟机,名称需要跟下面的命令行中的一样,例如本例中的: MacOS10.14Beta6 ,虚拟机类型为: Mac OS X , 版本为: Mac OS X(64 bit) , 设置一个内存,最好大于3G,在虚拟硬盘中选择\"使用已有的虚拟硬盘\",然后选择上面提供的vmdk虚拟机文件,如下截图: 镜像安装前用到的修改命令 关闭虚拟机在命令行对新建的虚拟机进行如下配置: ----- For Mac OS 10.14 Beta 6 cd \"C:\\Program Files\\Oracle\\VirtualBox\\\" VBoxManage.exe modifyvm \"MacOS10.14Beta6\" --cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbff VBoxManage setextradata \"MacOS10.14Beta6\" \"VBoxInternal/Devices/efi/0/Config/DmiSystemProduct\" \"iMac11,3\" VBoxManage setextradata \"MacOS10.14Beta6\" \"VBoxInternal/Devices/efi/0/Config/DmiSystemVersion\" \"1.0\" VBoxManage setextradata \"MacOS10.14Beta6\" \"VBoxInternal/Devices/efi/0/Config/DmiBoardProduct\" \"Iloveapple\" VBoxManage setextradata \"MacOS10.14Beta6\" \"VBoxInternal/Devices/smc/0/Config/DeviceKey\" \"ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc\" VBoxManage setextradata \"MacOS10.14Beta6\" \"VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC\" 1 ---- For Mac OS 10.13.6 cd \"C:\\Program Files\\Oracle\\VirtualBox\\\" VBoxManage.exe modifyvm \"MacOS10.13.6\" --cpuidset 00000001 000106e5 00100800 0098e3fd bfebfbff VBoxManage setextradata \"MacOS10.13.6\" \"VBoxInternal/Devices/efi/0/Config/DmiSystemProduct\" \"iMac11,3\" VBoxManage setextradata \"MacOS10.13.6\" \"VBoxInternal/Devices/efi/0/Config/DmiSystemVersion\" \"1.0\" VBoxManage setextradata \"MacOS10.13.6\" \"VBoxInternal/Devices/efi/0/Config/DmiBoardProduct\" \"Iloveapple\" VBoxManage setextradata \"MacOS10.13.6\" \"VBoxInternal/Devices/smc/0/Config/DeviceKey\" \"ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc\" VBoxManage setextradata \"MacOS10.13.6\" \"VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC\" 1 Mac OS 安装遇到的问题 错误提示 `Querying \" UUID \" failed (VERR_CFGM_VALUE_NOT_FOUND) Solution: because of EFI settings. If you already tried all combinations of EFI and Chipset (4 cases) and it still doesn't help then just give up. The VM won't work on your machine. 只需要在如下设置里面勾选\" 启用EFI \"即可.如下截图: When install \" there is no enough free space on sierra custom installer to install \" Solution: From the top menu, choose \"Utilities\"=> \"Disk Utility\",and open the dialog, see below screnenshot: then from the right check the virtualbox's disk and select \"Erasing\",and input the new disk name and format.etc. see below screenshot: Go back the install screenshot, or restart the virtualmachine, then you could see \" YOUR DISK NAME \" as an option on \"Install OS X\" screen as shown above. Stuck at first screen: Open virtualbox, change Guest Version to Other 64bit, select tab \"Storage\" and enable \"Use Host I/O Cache\" . Mouse and Keyboard not working: Install \"Oracle VM VirtualBox Extension Pack\" download from virtualbox website. Open VirtualBox, select tab \" USB \", click enable USB 3.0 Controller and add your Mouse to VirtualBox or in the USB 3.0 Controller Device Filters leave Empty . Mac OS 安装nodejs control + space 打开spotlight,输入\"终端\"，就打开了终端，类似win下的cmd; 输入 node -v , 回车; 输入 npm -v , 回车; 若无错，则显示版本号; Mac OS 安装cordova sudo npm install -g cordova 1. cordova create VRPanoApp com.yitieyilu.app VRPanoApp # 参数名称对应的是: 文件夹名称 包名称 和app名称 2. cordova platforms add android cordova platforms add ios cordova plugin add cordova-plugin-splashscreen --save cordova plugin add cordova-plugin-console --save 如果没有sudo则会报错，原因：由于 root 用户在 OS X 中具有特殊权限，因此对于特定的管理或故障诊断任务可能非常有用，但不适合日常使用。如果使用不慎，root 用户作出的更改可能只有通过重装 OS X 才能修复。考虑使用其他方式（如 sudo 命令）来代替启用 root 用户。 Mac OS 安装cordova依赖 sudo npm install -g ios-deploy - -unsafe-perm=t //代表真机运行环境 sudo npm install -g ios-sim //代表模拟器运行环境 virtualbox设置MAC OS X虚拟机共享剪切板 设置->高级->共享剪切板 双向，拖拽 双向 虚拟机设置-存储-控制器SATA-勾选\"使用主机输入输出(I/O)缓存\" 存储-控制器SATA-点击*.vdi-勾选\"固态驱动器\" 启动虚拟机->左上角divices->insert additional … 重启虚拟机 Mac OS虚拟机大小写切换，中英文切换 中文小写英文切换： –按一下caps lock键就可以实现中文小写英文切换 * 大小写切换： –不管是在中文状态下还是小写英文状态下，只要按住 shift 键就可以实现大写输入 * 大小写切换其他方式： –长按住caps lock键2s，caps lock灯亮即可切换到大写输入状态，这种情况适合于连续输入好多大写字母。输完了轻点一下caps lock就可以切换到非大写状态 How to update MacOS X 发现使用过iphone的就知道了,直接进入App Store 里面,然后搜索 MacOS ,里面会看到对应的版本,或者它这里会提示你是否有新的版本可以下载,确实很方便. 参考地址: https://jingyan.baidu.com/article/647f0115e342b97f2148a8ad.html Install XCode 10 beta 6 Need to upgrade Mac to the latest version, because XCode 10 Beta 6 need the Mac Version is Mac 10.13.6 or later. XCode对应的Mac版本列表 How to change the display resolution 参考地址 Virtualbox's virtual machine screen is too small, the below command to change the display resolution: cd \"C:\\Program Files\\Oracle\\VirtualBox\\\" --- For Mac OS 10.14 beta 6 VBoxManage setextradata \"MacOS10.14Beta6\" VBoxInternal2/EfiGraphicsResolution 1920x1080 --- For Mac OS 10.13 VBoxManage.exe setextradata global GUI/MaxGuestResolution any VBoxManage.exe setextradata \"MacOS10.13\" \"CustomVideoMode1\" \"1920x1080x32\" vboxmanage.exe controlvm \"MacOS10.13\" setvideomodehint 1920 1080 32 如何下载Google Driver中的文件 不要使用迅雷, 使用这个工具 Internet Download Manager 6.31 build 3 , 需要用到的 破解补丁 . 然后打开你的代理软件,回到Internet Download Manager中,选择\"选项\"=>\"代理服务器\",再在里面设置刚才对应的代理软件的主机和端口号. 使用感觉: 这个工具使用起来发现比迅雷的下载速度还要快 Virtualbox桥接上网连接配置 原理： 通过主机网卡，架设一条桥，直接连入到网络中。它使得虚拟机能被分配到一个网络中独立的IP，所有网络功能完全和在网络中的真实机器一样。 (虚拟机是通过主机所在网络中的DHCP服务得到ip地址的，所以按理来说，两者是完全独立的，但事实却是虚拟机是没有独立硬件的，它还是要依靠主机的网卡，因此，主机要断开网络，虚拟机也就没法拿到ip了，所以呵呵~~所有特点全消失咯） 设置步骤 2.1 Windows Host主机配置 > 在Windows中的网络连接(控制面板\\网络和 Internet\\网络连接),查看Virtualbox自动生成的Host-Only网络,这里不需要做任何的修改,按照默认的配置即可.Host主机中自动生成的配置如下: 2.2 VirtualBox中配置 点击VirtualBox的\"管理\"菜单,进入子菜单\"主机网络管理器\",然后在里面会自动创建一个Host Only Network,只启用这一个网络,这里的配置同控制面板\\网络和 Internet\\网络连接中VritualBox自动生成的Host-Only网络信息是一样的.如下截图: \" 主机网络管理器\"中选中这个新建的网络,然后在底部配置网卡和DHCP服务器,这里网卡选择\"手动配置网卡\", \"DHCP服务器\"按照默认配置不用再配置,如下截图: 2.3 虚拟机Mac OS Guest配置信息 进入Mac系统, 点击左上角的苹果标志,选择\"System Preferences\"=> \"Network\",点击进入查看对应的网络设置信息,默认情况下会采用DHCP自动获取IP地址,配置的网络信息同Host主机的网络信息一致,在同一个网络内.如下截图: 更新日志: 反复测试发现,虚拟机中的IP地址最好是 静态设置的IP ,发现DHCP形式的再桥接模式下,IP地址会变成: 165.254. . ,这个肯定是不能正常通信的. 注意一定要是静态的IP地址. Save XCode space XCode had installed with 15GB in my disk ,that's terrible, try to use below guideline to free the space: Saving up to 8. 5GB of Space After Every Apple Xcode Update Share file from Windows Host to Mac OS Guest The main problem is that how we can setup the Brige connection from host to guest machine? the steps for this you can refer above Virtualbox桥接上网连接配置 Section. Then following below steps: 在Mac电脑中,点击左上角的苹果标志,选择\"System Preferences\"=> \"Sharing\", 选择 \"File Sharing\",你也可以点击\"Options…\"按钮进行高级的配置,如下截图: 在Windows主机上,直接在地址栏中输入地址: \\你的Mac OS Guest的IP Addess , 按照提示输入对应的账号密码即可访问Mac OS中的文件系统,如下截图: 未完待续","tags":"Tools","url":"articles/install-mac-virtuabox/"},{"title":"七牛云配置详解(2018-09-04)","text":"问题 针对不同的公司设置不同的对象存储空间参数,这样不同的公司他们的资源存放在他们的服务器上,我们不接触用户的数据. 可以保存用户的数据的安全. 配置 用到的参数: 1. appKey 2. appSecret 3. BucketName","tags":"其他","url":"articles/qiniu-upload-config/"},{"title":"百度网盘不限速工具方式(2018-09-04更新)","text":"参考 参考的网页地址是: https://www.runningcheese.com/baiduyun 测试发现好用的是这款软件: https://github.com/proxyee-down-org/proxyee-down/releases ,绿色免安装,直接点击即可运行.","tags":"Tools","url":"articles/baiduyun-download-limit/"},{"title":"萤石云SDK接入学习路线(更新中)","text":"起因 公司需要接入摄像头的接口到我们自己的APP中,这样大家都可以在APP中查看施工现场的各个摄像头的情况动态. 考察 考察了国内和国外使用的摄像头设备供应商和相关的二次开发提供方案,发现也是部分网友的推荐,有两个摄像头做得比较好,一个是海康威视的萤石平台和对应的海康平台,萤石平台主打的是中小型规模的,比如住宅商铺工厂什么的,二对应大规模使用,比如施工现场,公共交通,治安防控和教育培训什么等等,推荐的是海康,他们有一套的系统解决方案. 还有一个厂家是大华,他们都是杭州本土的好像,做得比较成功在全国.在对比了他们相关的设备和产品的普遍性和二次开发方面的特性后,我们选择使用海康威视的监控设备. 开发文档 海康威视的开发文档, 进入海康威视官网 https://www.hikvision.com/cn/index.html ,点击菜单的\"服务支持\"=>\"下载\"=>\"SDK开发\". 萤石开发文档,进入萤石开发中心 https://open.ys7.com/ ,选择\"开发者服务\"进入即可. 接入步骤 进入\"开发者服务\"页面,点击\"我的应用\",这里新建一个你的应用,他们自动生成对应的OAuth对应的AppKey和Secret.","tags":"其他","url":"articles/ys-sdk-learn/"},{"title":"Available license server","text":"#0x01 IntelliJ Idea license servers http://xidea.online/servers.html #0x02 IntelliJ Idea Activate Code EB101IWSWD-eyJsaWNlbnNlSWQiOiJFQjEwMUlXU1dEIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In1dLCJoYXNoIjoiNjk0NDAzMi8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-Gbb7jeR8JWOVxdUFaXfJzVU/O7c7xHQyaidCnhYLp7v32zdeXiHUU7vlrrm5y9ZX0lmQk3plCCsW+phrC9gGAPd6WDKhkal10qVNg0larCR2tQ3u8jfv1t2JAvWrMOJfFG9kKsJuw1P4TozZ/E7Qvj1cupf/rldhoOmaXMyABxNN1af1RV3bVhe4FFZe0p7xlIJF/ctZkFK62HYmh8V3AyhUNTzrvK2k+t/tlDJz2LnW7nYttBLHld8LabPlEEjpTHswhzlthzhVqALIgvF0uNbIJ5Uwpb7NqR4U/2ob0Z+FIcRpFUIAHEAw+RLGwkCge5DyZKfx+RoRJ/In4q/UpA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== #0x03 Related Latest avaiable Server update at Site 2018-10-25","tags":"Java","url":"articles/jetbrain-idea-licenseserver/"},{"title":"JavaScript字符串数组中随机选择字符串","text":"代码 /** * 得到随机的字符串 * @param arrayStr * @returns {*} */ const randomStrPickUp = function ( arrayStr ) { const len = arrayStr . length const min = 0 const max = len - 1 const range = Math . round ( Math . random () * ( max - min )) + min // 得到随机的范围 return arrayStr [ range ] }","tags":"JavaScript","url":"articles/random_string/"},{"title":"vuejs項目转为android/ IOS App(Cordova)","text":"How to build android or IOS app from Vue project 1. cordova 环境准备 1.1 Java JDK 安装(省略) 1.2 Android SDK 安装配置 首先，下载Android SDK Tools，翻过墙的朋友可以去Google Android的官网上下载（http://developer.android.com/sdk/index.html）, 选择一个最新的版本就行了。如下图所示 * 按照提示一步步的安装完成后,回到安装目录如下: 然后就双击\" SDK Manager.exe\"，启动SDK Manager，如图所示： 这里我只说几个必须要安装的，如上图所示的，Tools文件夹里面的Android SDK Tools（这个我们在之前的一步已经下载好了的， 一般不会让你再安装了，不过有可能会让你更新），然后就是Android SDK Platform-tools和Android SDKBuild-tools， 注意只需要下载最新的版本就行了。 然后就是API的选择了。我们可以看到这里提供了很多很多从Android 2.2到Android 5.x的很多版本的API，那么怎么选择呢。 这里我建议，新手的话，选择一个最新的版本就好了，因为Android是向下兼容的。其他的以后你要用到了在下载就行了 （因为下载安装的速度实在太慢啦。。。）。所以如上图所示，这里我只选择了下载当前最新的Android 5.1.1( API 22)。 这里需要说明的是，如果你以后不打算用模拟器调试，而是一直用真机来调试的话，那么就可以不用装\"system images\"了。 不过新手的话，不知道怎么选择，还是建议直接全部勾上吧. 最后就是extras文件夹中的东西了，如下图所示: 理论上来说，extras中的东西如果网速允许，时间充沛的话，就都下载了。不过一开始安装的话，可以只用安装上图中的三个，即Android Support Repository、Android SupportLibrary和Google USB Driver。其他的以后有时间再慢慢下载吧。接下来就可以进行安装了,要注意，由于这些东西都是在google 的服务器上下载的。由于俺们天朝有墙，所以可能会出现连接不上的情况，如下图： 切换到国内镜像进行安装 遇到上面的安装错误,我们可以通过有Android SDK的国内镜像服务器来下载安装，这里推荐几个,参考这里的: http://tools.android-studio.org/index.php/proxy 随便选择一个就行啦。这里我选择的是第三个站点，即大连东软的镜像，使用方法如下： 然后在弹出的对话框中，填写HTTP Proxy Server为mirrors.neusoft.edu.cn（镜像服务器的地址，注意前面不要加http），然后填写HTTP Proxy Port为80 （端口号）。最后在勾选下面的『Forcehttps://… sources to be fetched using http://…』复选框，如下图所示: 接着点击close，关闭对话框，再 重新启动SDK Manager 就行啦。 经过漫长的下载安装过程后（建议在晚上睡觉的时候下载。。。），我们可以看到，之前选中安装的项目后面的状态都由之前的\"Not installed\"变为了如今的\"Installed\"，这就表示我们已经安装成功了！ SDK环境变量设置 右键我的电脑，打开属性，点击高级系统设置，打开环境变量. 新建一个环境变量名称为ANDROID_HOME，变量值为当前安装SDK的目录,例如SDK装在D:\\androidSDK中，则环境变量为： 把%ANDROID_HOME%\\platform-tools;%ANDROID_HOME%\\tools添加到Path环境变量中。 检测SDK 安装是否成功 1. win+R，输入cmd，打开命令提示符面板,输入 android : 弹出类似以下界面： 输入 abd 弹出类似以下界面： 输入 android -h 弹出类似以下界面说明安装完成. 直至所有的Android Sdk的环境配置部分都没有问题了. 1.3 Gradle 环境配置 下载gradle 1. 进入 点击打开链接 官网首页,点击 install gradle ,如下: 进入新的页面之后，找到并点击下载完整版本（英文看不懂可以先将网站翻译成中文）,如下: 下载完成之后，解压后放入自己想要放入的指定文件夹，我放入了C:\\WorkSoftware\\gradle-4.5,如下: 同上安装android SDK一样,新建一个环境变量: GRADLE_HOME ,设置为: C:\\WorkSoftware\\gradle-4.5 , 然后 path 环境变量中添加: %GRADLE_HOME%\\bin . 测试 gradle 命令: 如图显示对应的gradle的信息,说明gradle的配置成功! 1.4 genymotion虚拟设备配置 关于安装 genymotion 的步骤这里就不再赘余了,网上一搜一大堆.这里主要记录一些遇到的问题. 1. genymotion 安装成功后需要登录,这样才能使用它的增加device,下载镜像和设备android sdk的操作. 2. 针对`android SDK API >=28以上,安装apk文件直接闪退,网上说的是genymotion是基于intel pentium设计的, An error occured while deploying the file. This probably means that the app contains ARM native code and your Genymotion device cannot run ARM instructions. You should either build your native code to x86 or install an ARM translation tool in your device. 国内的就不要搜索, 都是一堆说使用 ARM_Translation.zip ,结果版本要不就是 android 5.0的就是6.0的,拖进去模拟器中.再次安装app还是直接闪退不能运行. ARM_Translation_oreo for android8.0安装包下载","tags":"JavaScript","url":"articles/vue-to-mobileapp-electron/"},{"title":"How to build the ftp system","text":"起因 需要搭建一个文件共享的服务器,这样可以方便的进行文件的共享和存取. 参考博客: 1. (smbd配置,忽略)https://www.conum.cn/os/linux/210.html 2. (vsftpdp配置)http://www.cnblogs.com/sunky/p/9418730.html 用到的操作命令如下: 1. 安装vsftpd $ apt-get install vsftpd 安装完成后,会新建一个用户组ftp和对应的用户名ftp,通过下面的命令查看他的配置 $ sudo nano /etc/passwd 已经设置成了/srv/ftp目录,这里把它改成 /ftp目录 2. 安装用户名和密码存放的数据库文件 $ aptitude search db | grep util $ aptitude install db5.3-util $ db5.3_load -T -t hash -f /etc/vsftpd/login.txt /etc/vsftpd/vsftpd_login.db 3. 查看log $ tail -f -n 50 /var/log/auth.log 4. 增加用户 4.1 先在login.txt文件中增加一行用户名记录,再另起一行加上对应的密码,保存. 4.2 然后在/etc/vsftpd/confs/ 文件夹中新建一个文件,文件名称是该用户名,例如用户名是`test`,那么执行如下命令: sudo nano test # 加入下面的配置代码 local_root=/ftp/vsftp/foldername anon_world_readable_only=NO write_enable=YES anon_mkdir_write_enable=YES anon_upload_enable=YES anon_other_write_enable=YES 常见错误 500 OOPS : bad bool value in config file for: anon_world_readable_only 原因是你的配置文件中带有空格,使用下面的命令去除空格: # sed -i 's,\\r,,;s, *$,,' /etc/vsfttpd/confs/yourusername # db5.3_load -T -t hash -f /etc/vsftpd/login.txt /etc/vsftpd/vsftpd_login.db # systemctl restart vsftpd.service","tags":"Linux","url":"articles/vsftp_setup/"},{"title":"Vue项目转成Cordova项目的注意事项和技巧","text":"cordova build android 命令 timeout 修改对应的 build.gradle 文件中的内容为如下内容: buildscript { repositories { // jcenter() maven { url \" http : // maven . aliyun . com / nexus / content / groups / public / \" } } dependencies { // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files classpath 'com.android.tools.build:gradle:3.0.0' } } allprojects { repositories { // jcenter() maven { url \" http :// maven . aliyun . com / nexus / content / groups / public / \" } } //This replaces project.properties w.r.t. build settings project.ext { defaultBuildToolsVersion=\" 25.0.2 \" // String defaultMinSdkVersion = 19 // Integer - Minimum requirement is Android 4.4 defaultTargetSdkVersion = 26 // Integer - We ALWAYS target the latest by default defaultCompileSdkVersion = 26 // Integer - We ALWAYS compile with the latest by default } } task clean ( type : Delete ) { delete rootProject.buildDir } 设置图标 在cordova5.0版本以后，需要安装cordova-plugin-splashscreen插件以后才能修改和设置App的启动页面。 安装splashscreen插件 cordova plugin add cordova-plugin-splashscreen 或 cordova plugin add https://github.com/apache/cordova-plugin-splashscreen.git 基本配置 在你的config.xml文件中(一般在如下目录类似: projectname/config.xml)，添加以下代码: < platform name = \"android\" > < icon density = \"ldpi\" src = \"res/icon/android/icon-36-ldpi.png\" /> < icon density = \"mdpi\" src = \"res/icon/android/icon-48-mdpi.png\" /> < icon density = \"hdpi\" src = \"res/icon/android/icon-72-hdpi.png\" /> < icon density = \"xhdpi\" src = \"res/icon/android/icon-96-xhdpi.png\" /> < icon density = \"xxhdpi\" src = \"res/icon/android/icon-144-xxhdpi.png\" /> < icon density = \"xxxhdpi\" src = \"res/icon/android/icon-192-xxxhdpi.png\" /> < splash density = \"land-hdpi\" src = \"res/screen/android/screen-hdpi-landscape.png\" /> < splash density = \"land-ldpi\" src = \"res/screen/android/screen-ldpi-landscape.png\" /> < splash density = \"land-mdpi\" src = \"res/screen/android/screen-mdpi-landscape.png\" /> < splash density = \"land-xhdpi\" src = \"res/screen/android/screen-xhdpi-landscape.png\" /> < splash density = \"port-hdpi\" src = \"res/screen/android/screen-hdpi-portrait.png\" /> < splash density = \"port-ldpi\" src = \"res/screen/android/screen-ldpi-portrait.png\" /> < splash density = \"port-mdpi\" src = \"res/screen/android/screen-mdpi-portrait.png\" /> < splash density = \"port-xhdpi\" src = \"res/screen/android/screen-xhdpi-portrait.png\" /> </ platform > < platform name = \"ios\" > <!-- iOS 8.0 + --> <!-- iPhone 6 Plus --> < icon src = \"res/icon/ios/icon-60@3x.png\" width = \"180\" height = \"180\" /> <!-- iOS 7.0 + --> <!-- iPhone / iPod Touch --> < icon src = \"res/icon/ios/icon-60.png\" width = \"60\" height = \"60\" /> < icon src = \"res/icon/ios/icon-60@2x.png\" width = \"120\" height = \"120\" /> <!-- iPad --> < icon src = \"res/icon/ios/icon-76.png\" width = \"76\" height = \"76\" /> < icon src = \"res/icon/ios/icon-76@2x.png\" width = \"152\" height = \"152\" /> <!-- iOS 6.1 --> <!-- Spotlight Icon --> < icon src = \"res/icon/ios/icon-40.png\" width = \"40\" height = \"40\" /> < icon src = \"res/icon/ios/icon-40@2x.png\" width = \"80\" height = \"80\" /> <!-- iPhone / iPod Touch --> < icon src = \"res/icon/ios/icon.png\" width = \"57\" height = \"57\" /> < icon src = \"res/icon/ios/icon@2x.png\" width = \"114\" height = \"114\" /> <!-- iPad --> < icon src = \"res/icon/ios/icon-72.png\" width = \"72\" height = \"72\" /> < icon src = \"res/icon/ios/icon-72@2x.png\" width = \"144\" height = \"144\" /> <!-- iPhone Spotlight and Settings Icon --> < icon src = \"res/icon/ios/icon-small.png\" width = \"29\" height = \"29\" /> < icon src = \"res/icon/ios/icon-small@2x.png\" width = \"58\" height = \"58\" /> < icon src = \"res/icon/ios/icon-small@3x.png\" width = \"87\" height = \"87\" /> <!-- iPad Spotlight and Settings Icon --> < icon src = \"res/icon/ios/icon-50.png\" width = \"50\" height = \"50\" /> < icon src = \"res/icon/ios/icon-50@2x.png\" width = \"100\" height = \"100\" /> < splash src = \"res/screen/ios/Default~iphone.png\" width = \"320\" height = \"480\" /> < splash src = \"res/screen/ios/Default@2x~iphone.png\" width = \"640\" height = \"960\" /> < splash src = \"res/screen/ios/Default-Portrait~ipad.png\" width = \"768\" height = \"1024\" /> < splash src = \"res/screen/ios/Default-Portrait@2x~ipad.png\" width = \"1536\" height = \"2048\" /> < splash src = \"res/screen/ios/Default-Landscape~ipad.png\" width = \"1024\" height = \"768\" /> < splash src = \"res/screen/ios/Default-Landscape@2x~ipad.png\" width = \"2048\" height = \"1536\" /> < splash src = \"res/screen/ios/Default-568h@2x~iphone.png\" width = \"640\" height = \"1136\" /> < splash src = \"res/screen/ios/Default-667h.png\" width = \"750\" height = \"1334\" /> < splash src = \"res/screen/ios/Default-736h.png\" width = \"1242\" height = \"2208\" /> < splash src = \"res/screen/ios/Default-Landscape-736h.png\" width = \"2208\" height = \"1242\" /> </ platform > 应用程序启动的图标和时间 参考文章: https://www.jianshu.com/p/3ad9538cf5fe <!--自动隐藏启动页面AutoHideSplashScreen--> <preference name=\"AutoHideSplashScreen\" value=\"false\" /> <!--显示启动页面的时间长度SplashScreenDelay--> <preference name=\"SplashScreenDelay\" value=\"3000\" /> <!--是否显示淡入淡出效果--> <preference name=\"FadeSplashScreen\" value=\"true\"/> <!--FadeSplashScreenDuration时间是包含在SplashScreenDelay的时间里的。--> <preference name=\"FadeSplashScreenDuration\" value=\"750\"/>","tags":"JavaScript","url":"articles/cordova-android/"},{"title":"Linux安装包遇到的问题","text":"起因 在尝试安装samba的时候,服务器端总是报如下的错误: error processing package python-dnspython Sub-process /usr/bin/dpkg returned an error code (1) 解决方法 参考博客：https://www.cnblogs.com/anpengapple/p/5098960.html 中说是dpkg目录中的info目录异常，然而直接删除这个目录会导致一些问题(苦逼的这个问题可能就是我把Ubuntu中的默认python由2改到3，然后在纠正之后出现的一系列问题中越走越远。。。。)，所以先备份，更新一下这个目录： sudo mv /var/lib/dpkg/info/ /var/lib/dpkg/info_backup/ sudo mkdir /var/lib/dpkg/info/ xlwt flask xlwt 中文'latin-1' codec can't encode characters in positio response = make_response(send_from_directory(directory, filename, as_attachment=True)) response.headers[\"Content-Disposition\"] = \"attachment; filename={0}\".format(filename.encode('utf-8')) response.direct_passthrough = False return response 注意返回的中文名称需要转码为utf-8","tags":"Python","url":"articles/python-error/"},{"title":"[Linux] (持续更新中)一些常用的linux系统的操作命令","text":"关键字 free top 防火墙操作 显示防火墙状态 $ sudo iptables -L 关闭防火墙 $ sudo iptables -F #flush 清空所有的规则 添加到防火墙中 $ sudo iptables -A FIREWALL -p tcp -m tcp –dport 80 –syn -j ACCEPT # -A append # -p protocol # -m match # -d destination # -j jump $ sudo iptables -A FIREWALL -p tcp -m tcp --dport 22 --syn -j ACCEPT # 打开22端口 $ sudo iptables-save > /etc/firewall-rules 性能相关的命令 与 df 不一样的是，du会直接到文件系统内查找所有的文件数据。 # df -lh # 查看磁盘空间 # du -ah --max-depth=1 这个是我想要的结果 a表示显示目录下所有的文件和文件夹（不含子目录），h表示以人类能看懂的方式，max-depth表示目录的深度。 ```` ### 统计文件个数 统计当前文件夹下文件的个数，包括子文件夹里的 `ls -lR|grep \"&#94;-\"|wc -l` 统计文件夹下目录的个数，包括子文件夹里的 `ls -lR|grep \"&#94;d\"|wc -l` 统计当前文件夹下文件的个数 `ls -l |grep \"&#94;-\"|wc -l` 统计当前文件夹下目录的个数 `ls -l |grep \"&#94;d\"|wc -l` 附： 统计输出信息的行数 `wc -l` 将长列表输出信息过滤一部分，只保留一般文件，如果只保留目录就是 &#94;d `grep \"&#94;-\"` ### 切换语言环境为英文 参考文章: https://blog.csdn.net/yygydjkthh/article/details/47694747 $ sudo export LANG =en_US. UTF -8 $ dpkg-reconfigure locales # 点击空格选择en_US_UTF-8,点击空格去掉zh_CN_UTF-8 $ locale -a ### 磁盘管理,加载新的磁盘 参加文档: https://www.fujieace.com/linux/no-partition-is-defined-yet.html 阿里云的帮助文档,注意ext3格式,实际的系统格式是ext4:https://help.aliyun.com/document_detail/25426.html?spm=a2c4g.11186623.2.9.u398NC No partition is defined yet! Could not delete partition 1 > 删除磁盘 `fdisk d`的时候一定要注意清空文件 `/etc/fstab`里面的内容,否则容易出现很大的问题. fdisk -l fdisk /dev/sdb mkfs.ext4 /dev/sdb1 nano /etc/fstab 这里加上对应的需要加载的磁盘的信息 mount /dev/sdb1 ### install ZH_CN.UTF-8语言支持 查看当前配置语言环境 $ locale -a 安装语言包 $ sudo apt-get install locales 配置选择语言,按空格选择对应的字符集 $ sudo dpkg-reconfigure locales locale的设定： LC_ALL和LANG优先级的关系：LC_ALL > LC_* > LANG 修改文件(debian系列)：/etc/default/locale 修改文件(redhat系列)：/etc/sysconfig/i18n 1、如果需要一个纯中文的系统的话，设定LC_ALL=zh_CN. XXXX ，或者LANG=zh_CN.XXXX都可以。 2、如果只想要一个可以输入中文的环境，而保持菜单、标题，系统信息等等为英文界面，那么只需要设定 LC_CTYPE=zh_CN. XXXX ， LANG =en_US.XXXX就可以了。 3、假如什么也不做的话，也就是LC_ALL，LC_*和LANG均不指定特定值的话，系统将采用POSIX作为lcoale，也就是C locale。 $ sudo nano /etc/default/locale 临时设定编码：[nick@ubuntu~]$ export LC_ALL=\"zh_CN. GBK \" 2、永久设定编码：修改文件/etc/profile（对所有用户有效）或者~/.bash_profile。在文件尾加入export LC_ALL=zh_CN. GBK $ sudo nano /etc/profile 命令行中英文切换,本地安装的是中文字符集 $ export LC_ALL=C $ unset LC_ALL \" `","tags":"Linux","url":"articles/basic-command/"},{"title":"[面试] 5. 性能测试相关的涉及内容","text":"前言 今天到一家初创型的公司去参加了一轮面试,面试了好久性能测试相关的东西,好多年没有做这个了,突然问起来,感觉好痛苦. 可是也无奈, 因为自己选择了这个行业.还是需要自己重拾这些遗忘的东西,所以我这里就梳理一下自己所知道的重要的检查点. 关键字 TPS (Transaction Per Second) PV (Page View) PR (Page Response) 2017-07-26 反馈 深拷贝和浅拷贝的区别? Appinum的使用,能在测试吗? 静态方法中可以使用 this 和 super 吗? 2017-07-25 反馈 UI 测试用到哪些工具? 你对所列到的python和java语言哪种最擅长? Http和接口有什么区别? 抽象类和普通类有什么区别? java的overload和override的区别? java中的Error和Exception的区别? 给一个测试方法,里面有十个入参,每个参数都有十种不同的值,按照普通的思路可能会涉及10*10的测试用例,怎么设计测试用例可以用最少的用例覆盖更多的功能? 给一个数组,然后返回一个没有重复的新的数组,要求不借助其他任何第三方包或者库(包括Set,ArrayList)? Python中的装饰器谈谈你的理解? java中的顶级类是什么? Python中的list,tuple,set,dict的区别作用,写出对应的他们的增删改查操作?","tags":"面试","url":"articles/5-software-performance-testing/"},{"title":"[ SQL ]收集的一些好的SQL snippets","text":"MYSQL 用户变量,系统变量,局部变量 参考文档: https://stackoverflow.com/questions/11754781/how-to-declare-a-variable-in-mysql 1. 用户变量: 基于会话变量实现的, 可以暂存值, 并传递给同一连接里的下一条sql使用的变量.当客户端连接退出时,变量会被释放。只针对当前的存储过程或者当前的执行环境有效. 对于SET，可以使用=或:=来赋值，对于SELECT只能使用:=来赋值. 我们可以使用一条简单的select语句查询定义的用户变量的值。 2. 系统变量: MySQL可以访问许多系统变量。当服务器运行时许多变量可以动态更改。这样通常允许你修改服务器操作而不需要停止并重启服务器。当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中指定的选项进行更改。服务器启动后，通过连接服务器并执行SET GLOBAL var_name语句，可以动态更改这些全局变量。 3. 局部变量: 作用范围在begin到end语句块之间。在该语句块里设置的变量成为局部变量。 基本的排序显示 -- MYSQL 方式 SELECT * FROM SCore s ORDER BY s.score DESC LIMIT 3; -- SQL SERVER 方式 SELECT TOP 3 * FROM SCore s ORDER BY s.score DESC; 查询分数排名第二的人(排序第二) -- MYSQL方式, LIMIT第一参数是查询的条数,第二个数是查询的索引值,从0开始 SELECT * FROM SCore s ORDER BY s.score DESC LIMIT 1,1; -- SQL Server 方式 SELECT TOP 1 * FROM Score s WHERE s.id NOT IN ( SELECT TOP 1 * FROM Score ORDER BY s.score DESC ) ORDER BY s.score DESC; 显示排名名次或者说对应的行号 -- MYSQL方式 SELECT s . username , s . score , @ rank := @ rank + 1 FROM Score s join ( SELECT @ ranK := 0 ) r order by 1 DESC ; 查询父节点下的所有子节点集合 CREATE DEFINER = 'test'@'%' FUNCTION test.func_getMyFollowings(inputuserKey INT(11)) RETURNS varchar(5000) CHARSET utf8 BEGIN DECLARE rootNode varchar(100); DECLARE tempChilds varchar(5000); SET tempChilds =''; SET rootNode=CAST(inputuserKey AS CHAR); WHILE rootNode IS NOT NULL DO -- 遍历节点操作 SET tempChilds = concat(tempChilds,rootNode,','); SELECT group_concat(um.EmployeeUserKey) INTO rootNode FROM UserManager um where FIND_IN_SET(um.ManagerSUserKey,rootNode)>0; -- 找到当前节点的子节点 END WHILE; RETURN tempChilds; END MYSQL中的 concat 和 concat_ws 和 group_concat 的区别","tags":"SQL","url":"articles/sql-best-tips/"},{"title":"分层自动化测试","text":"这是第一次听到这个理念,其实描述的是各个阶段的测试.传统的自动化测试更关注的产品UI层的自动化测试，而分层的自动化测试 倡导产品的不同阶段（层次）都需要自动化测试. 能够帮助测试人员从重复、枯燥的手工测试中解放出来。 最早是google进行的实践，google在测试之初就做了非常优秀的测试覆盖，单元测试，接口测试，而web测试方面，他们只进行了很少的自动化， 甚至是全手工测试页面。这种模式的效率很高，效果也很好，产品质量高，而且上线迅速。这种模式逐渐被百度接受。 1、把传统的UI测试逐步弱化 2、增加接口测试，白盒测试的比重 3、利用系统级mock技术解耦 自动化测试越底层收益越大,做分层,需要结合缺陷等数据,做最有价值的区域. 不要为了持续集成而集成,注重基础建设; 将能够自动的都部署到CI上,更有价值; UI最好是手工测试。接口非常适合自动化。 参考阿里PPT 参考: 如何做好自动化测试，揭秘阿里巴巴分层自动化实践之路 1. 单元测试（unit）：它可以通过mock框架，模拟各种异常场景，外部依赖最少，且可以做到测试粒度到最小的一种测试方法。 也因为依赖少，可方便随时随地执行，也让问题排查很简单。这是一切测试的地基。 2. 接口测试（service）：这里要求测试人员对系统的结构和系统间的调度非常清楚，同时要了解接口逻辑关系，否则接口测试代码很 容易遗漏一些异常场景。这一层由于含有一些业务逻辑和多接口的一个集成，所以相对单元测试来说，多了一些外界依赖，导致问题定位 不会有单元测试层那么准确。因此投入会比单元测试多一些。 3. 页面测试（ UI ）：是常见的黑盒自动化测试场景。它最接近用户真实场景，也容易发现问题，但它的实现成本最高且太容易受外部依赖， 影响脚本成功率，所以处在金字塔的顶端，但它不是金字塔的全部。自动化测试的劣势，其中80%都是因为UI自动化。 分层自动化测试倡导的就是，将系统分层，不同层次用合适的自动化方法进行测试的一种测试策略。某个项目是否都能用自动化覆盖， 那就要看测试负责人的分层策略是否合理、全面。 自动化用的好可以大幅提升效率，降低成本投入，用不好则可能成为测试鸡肋，妨碍测试进程。 集成、接口测试对于不少测试新手来说不太容易理解，单元测试关注代码的实现逻辑，例如一个if 分支或一个for循环的实现； 那么集成、接口测试关注的一是个函数、类（方法）所提供的接口是否可靠。例如，我定义一个add()函数用于计算两个参数的 结果并返回，那么我需要调用add()并传参，并比较返回值是否两个参数相加。当然，接口测试也可以是url的形式进行传递。 例如，我们通过get方式向服务器发送请求，那么我们发送的内容做为URL的一部分传递到服务器端。但比如 Web service 技术对外提供的一个公共接口，需要通过soapUI 等工具对其进行测试。 UI层的自动化测试，这个大家应该再熟悉不过了，大部分测试人员的大部分工作都是对UI层的功能进行测试。例如，我们不断重复的对 一个表单提交，结果查询等功能进行测试，我们可以通过相应的自动化测试工具来模拟这些操作，从而解放重复的劳动。 UI层的自动化测试工具非常多，比较主流的是QTP，Robot Framework、watir、selenium 等。 这是为了表示不同阶段所投入自动化测试的比例。如果一个产品从没有做单元测试与接口测试，只做UI层的自动化测试是不科学的， 从而很难从本质上保证产品的质量。如果你妄图实现全面的UI层的自动化测试，那更是一个劳民伤财的举动，投入了大量人力时间， 最终获得的收益可能会远远低于所支付的成本。因为越往上层，其维护成本越高。尤其是UI层的元素会时常的发生改变。所以，我们应该把更多的 自动化测试放在单元测试与接口测试阶段进行。 既然UI层的自动化测试这么劳民伤财，那我们只做单元测试与接口测试好了。 NO ! 因为不管什么样的产品，最终呈现给用户的是UI层。所以， 测试人员应该更多的精力放在UI层。那么也正是因为测试人员在UI层投入大量的精力，所以，我们有必要通过自动化的方式帮助我们\"部分解放\" 重复的劳动。 在自动化测试中最怕的是变化，因为变化的直接结果就是导致测试用例的运行失败，那么就需要对自动化脚本进行维护；如何控制失败，降低维护 成本对自化的成败至关重要。反过来讲，一份永远都运行成功的自动化测试用例是没有价值`。 至于在金字塔中三种测试的比例要根据实际的项目需求来划分。在《google 测试之道》一书，对于google产品，70%的投入为单元测试， 20%为集成、接口测试，10% 为UI层的自动化测试。 因为测试门槛的降低,从测试人员自身的发展来说，我其实非常需要通过自动化技术来增加自己有竞争力。 当然，做到一定年限测试人员会选择转管理或其它岗位，这又是另一个话题了。 是否该自动化测试??? 首先考考虑产品是否适合做自动化测试。这方法比较普遍的共识是从三个方面进行权衡。 1. 软件需求变动不频繁 测试脚本的稳定性决定了自动化测试的维护成本。如果软件需求变动过于频繁，测试人员需要根据变动的需求来更新测试用例以及相关的测试脚本， 而脚本的维护本身就是一个代码开发的过程，需要修改、调试，必要的时候还要修改自动化测试的框架，如果所花费的成本不低于利用其节省的测试成本，那么自动化测试便是失败的。 2. 项目周期较长 由于自动化测试需求的确定、自动化测试框架的设计、测试脚本的编写与调试均需要相当长的时间来完成。这样的过程本身就是一个测试软件的开 发过程，需要较长的时间来完成。如果项目的周期比较短，没有足够的时间去支持这样一个过程，那么自动化测试便成为笑谈。 自动化测试脚本可重复使用 自动化测试脚本的重复使用要从三个方面来考量，一方面所测试的项目之间是否很大的差异性（如C/S系统和B/S系统的差异）；所选择的测试工具是否适应这种差异； 最后，测试人员是否有能力开发出适应这种差异的自动化测试框架。 选择什么工具进行自动化测试 首先要先确认你所测试的产品是桌面程序（C/S）还是web应用（B/S）。 桌面程序的工具有： QTP 、 AutoRunner web应用的工具有： QTP 、AutoRunner、Robot Framework、watir、selenium selenium 用前须知 在selenium 2.0 中主推的是WebDriver ，WebDriver 是selenium RC 的替代品，因为 selenium 为了向下兼容性，所以selenium RC 并没有彻底抛弃， 如果你使用selenium开发一个新自动化测试项目，强列推荐使用WebDriver 。那么selenium RC 与webdriver 主要有什么区别呢？ selenium RC 在浏览器中运行JavaScript应用，使用浏览器内置的JavaScript 翻译器来翻译和执行selenese命令（selenese 是selenium命令集合）。 WebDriver通过原生浏览器支持或者浏览器扩展直接控制浏览器。WebDriver针对各个浏览器而开发，取代了嵌入到被测Web应用中的JavaScript。 与浏览器的紧密集成支持创建更高级的测试，避免了JavaScript安全模型导致的限制。除了来自浏览器厂商的支持，WebDriver还利用操作系统级的调用模拟用户输入。","tags":"SoftwareTesting","url":"articles/fen-ceng/"},{"title":"[面试] 1. 面向对象的相关概念","text":"这里整理的是针对面向对象的相关问题和面试中可能涉及的问题. 达到目的 面向对象三大特性,封装 (Encapsulation) , 继承 (Inheritance) 和多态 (Polymorphism)","tags":"Java","url":"articles/1-object-oriented-programming/"},{"title":"需要知道的一些算法","text":"费布拉切数列 1 1 2 3 5 8 13 21 public Integer fibonacci(int n){ if(n<=2){ return 1; }else { return fibonacci(n-1)+fibonacci(n-2); } } 有A、B两个水杯，都没有刻度，也不允许做刻度。A杯装满水是5升，B杯装满水是3升。 不借助别的任何工具，只用这两个杯子如何精确的得到4升水？ 把装满3升的水倒进5升的杯子里面，再把装满3升的水倒到5升的杯子，只倒了2升5升的杯子就满了，而3升的杯子里面还有1升水，将5升的杯子的水倒空， 将3升杯子里面的1升水倒进5升杯子里，再将装满3升水全部倒进5升杯子里，那么5升杯子里面现在有4升水。 冒泡排序。用C 或 Java 语言。（从小到大排序）","tags":"Java","url":"articles/algorithm-best/"},{"title":"[面试]测试面试的问题整理","text":"1、问：你在测试中发现了一个bug，但是开发经理认为这不是一个bug，你应该怎样解决？ 首先，将问题提交到缺陷管理库里面进行备案。 然后，要获取判断的依据和标准： 根据需求说明书、产品说明、设计文档等，确认实际结果是否与计划有不一致的地方，提供缺陷是否确认的直接依据； 如果没有文档依据，可以根据类似软件的一般特性来说明是否存在不一致的地方，来确认是否是缺陷； 根据用户的一般使用习惯，来确认是否是缺陷； 与设计人员、开发人员和客户代表等相关人员探讨，确认是否是缺陷； 合理的论述，向测试经理说明自己的判断的理由，注意客观、严谨，不参杂个人情绪。 等待测试经理做出最终决定，如果仍然存在争议，可以通过公司政策所提供的渠道，向上级反映，并有上级做出决定。 2、问：给你一个网站，你如何测试？ 首先，查找需求说明、网站设计等相关文档，分析测试需求。 制定测试计划，确定测试范围和测试策略，一般包括以下几个部分：功能性测试；界面测试；性能测试；数据库测试；安全性测试；兼容性测试 设计测试用例： 功能性测试可以包括，但不限于以下几个方面： 链接测试。链接是否正确跳转，是否存在空页面和无效页面，是否有不正确的出错信息返回。 提交功能的测试。 多媒体元素是否可以正确加载和显示。 多语言支持是否能够正确显示选择的语言等。 界面测试可以包括但不限于一下几个方面： 页面是否风格统一，美观 页面布局是否合理，重点内容和热点内容是否突出 控件是否正常使用 对于必须但未安装的控件，是否提供自动下载并安装的功能 文字检查 性能测试一般从以下两个方面考虑： 压力测试；负载测试；强度测试 数据库测试要具体决定是否需要开展。数据库一般需要考虑连结性，对数据的存取操作，数据内容的验证等方面。 安全性测试： 基本的登录功能的检查 是否存在溢出错误，导致系统崩溃或者权限泄露 相关开发语言的常见安全性问题检查，例如SQL注入等 如果需要高级的安全性测试，确定获得专业安全公司的帮助，外包测试，或者获取支持 兼容性测试，根据需求说明的内容，确定支持的平台组合： 浏览器的兼容性； 操作系统的兼容性； 软件平台的兼容性； 数据库的兼容性 开展测试，并记录缺陷。合理的安排调整测试进度，提前获取测试所需的资源，建立管理体系（例如，需求变更、风险、配置、测试文档、缺陷报告、人力资源等内容）。 定期评审，对测试进行评估和总结，调整测试的内容。 3、在搜索引擎中输入汉字就可以解析到对应的域名，请问如何用LoadRunner进行测试。 建立测试计划，确定测试标准和测试范围 设计典型场景的测试用例，覆盖常用业务流程和不常用的业务流程等 根据测试用例，开发自动测试脚本和场景： 录制测试脚本：新建一个脚本（Web/HTML协议）；点击录制按钮，在弹出的对话框的URL中输入\"about:blank\"；在打开的浏览器中进行正常操作流程后，结束录制；调试脚本并保存，可能要注意到字符集的关联。 设置测试场景：针对性能设置测试场景，主要判断在正常情况下，系统的平均事务响应时间是否达标；针对压力负载设置测试场景，主要判断在长时间处于满负荷或者超出系统承载能力的条件下，系统是否会崩溃；执行测试，获取测试结果，分析测试结果 4、问：一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别? 300个用户在一个客户端上，会占用客户机更多的资源，而影响测试的结果。线程之间可能发生干扰，而产生一些异常。 300个用户在一个客户端上，需要更大的带宽。 IP地址的问题，可能需要使用IP Spoof来绕过服务器对于单一IP地址最大连接数的限制。 所有用户在一个客户端上，不必考虑分布式管理的问题；而用户分布在不同的客户端上，需要考虑使用控制器来整体调配不同客户机上的用户。同时，还需要给予相应的权限配置和防火墙设置。 5、试述软件的概念和特点？软件复用的含义？构件包括哪些？ 软件是计算机系统中与硬件相互依存的另一部分，与计算机系统操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据。 软件复用(SoftWare Reuse)是将已有软件的各种有关知识用于建立新的软件，以缩减软件开发和维护的花费。软件复用是提高软件生产力和质量的一种重要技术。早期的软件复用主要是代码级复用，被复用的知识专指程序，后来扩大到包括领域知识、开发经验、设计决定、体系结构、需求、设计、代码和文档等一切有关方面。 可以被复用的软件成分一般称作可复用构件 6、软件生存周期及其模型是什么？ 软件生存周期（Software life cycle）又称为软件生命期，生存期。是指从形成开发软件概念起，所开发的软件使用以后，知道失去使用价值消亡为止的整个过程。一般来说，整个生存周期包括计划（定义）、开发、运行（维护）三个时期，每个时期又划分为若干个阶段。每个阶段有明确的任务。 周期模型（典型的几种）： 瀑布模型 快速原型模型：快速原型模型允许在需求分析阶段对软件的需求进行初步而非完全的分析和定义，快速设计开发出软件系统的原型，该原型向用户展示待开发软件的全部或部分功能和性能；用户对该原型进行测试评定，给出具体改进意见以丰富细化软件需求；开发人员据此对软件进行修改完善，直至用户满意认可之后，进行软件的完整实现及测试、维护。 迭代模型：迭代包括产生产品发布（稳定、可执行的产品版本）的全部开发活动和要使用该发布必需的所有其他外围元素。在某种程度上，开发迭代是一次 完整地经过所有工作流程的过程：需求分析、设计、实施和测试工作流程。实质上，它类似小型的瀑布式项目。RUP认为，所有的阶段都可以细分为迭代。每一次 的迭代都会产生一个可以发布的产品，这个产品是最终产品的一个子集。 生命周期阶段： 软件计划与可行性分析 需求分析 软件设计 编码 软件测试 运行与维护 7、什么是软件测试？软件测试的目的与原则 在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。 软件测试的目的： 测试是程序的执行过程，目的在于发现错误 一个成功的测试用例在于发现至今未发现的错误 一个成功的测试是发现了至今未发现的错误的测试 确保产品完成了它所承诺或公布的功能，并且用户可以访问到的功能都有明确的书面说明。 确保产品满足性能和效率的要求 确保产品是健壮的和适应用户环境的 软件测试的原则： 测试用例中一个必须部分是对预期输出或接过进行定义 程序员应避免测试自己编写的程序 编写软件的组织不应当测试自己编写的软件 应当彻底检查每个测试的执行结果 测试用例的编写不仅应当根据有效和预料到的输入情况，而且也应当根据无效和未预料到的输入情况 检擦程序是否\"未做其应该做的\"仅是测试的一半，测试的另一半是检查程序是否\"做了其不应该做的\" 应避免测试用例用后即弃，除非软件本身就是个一次性的软件 计划测试工作时不应默许假定不会发现错误 程序某部分存在更多错误的可能性，与该部分已经发现错误的数量成正比 软件测试是一项极富创造性，极具智力的挑战性的工作 8、软件配置管理的作用？软件配置包括什么？ 软件配置管理（Software Configuration Management， SCM ）是一种标识、组织和控制修改的技术。软件配置管理应用于整个软件工程过程。在软件建立时变更是不可避免的，而变更加剧了项目中软件开发者之间的混乱。SCM活动的目标就是为了标识变更、控制变更、确保变更正确实现并向其他有关人员报告变更。从某种角度讲，SCM是一种标识、组织和控制修改的技术，目的是使错误降为最小并最有效地提高生产效率。 软件配置包括如下内容：配置项识别、工作空间管理、版本控制、变更控制、状态报告、配置审计 9、什么是软件质量？ 概括地说，软件质量就是\"软件与明确的和隐含的定义的需求相一致的程度\"。具体地说，软件质量是软件符合明确叙述的功能和性能需求、文档中明确描述 的开发标准、以及所有专业开发的软件都应具有的隐含特征的程度。 影响软件质量的主要因素，这些因素是从管理角度对软件质量的度量。可划分为三组，分别反应用户在使用软件产品时的三种观点。正确性、健壮性、效率、完整性、可用性、风险（产品运行）；可理解性、可维修性、灵活性、可测试性（产品修改）；可移植性、可再用性、互运行性（产品转移）。 10、目前主要的测试用例设计方法是什么？ 白盒测试：逻辑覆盖、循环覆盖、基本路径覆盖 黑盒测试：边界值分析法、等价类划分、错误猜测法、因果图法、状态图法、测试大纲法、随机测试、场景法 11、软件的安全性应从哪几个方面去测试？ 软件安全性测试包括程序、数据库安全性测试。根据系统安全指标不同测试策略也不同。 用户认证安全的测试要考虑问题： 明确区分系统中不同用户权限 、系统中会不会出现用户冲突 、系统会不会因用户的权限的改变造成混乱 、用户登陆密码是否是可见、可复制 、是否可以通过绝对途径登陆系统（拷贝用户登陆后的链接直接进入系统）、用户退出系统后是否删除了所有鉴权标记，是否可以使用后退键而不通过输入口令进入 系统 、系统网络安全的测试要考虑问题 、测试采取的防护措施是否正确装配好，有关系统的补丁是否打上 、模拟非授权攻击，看防护系统是否坚固 、采用成熟的网络漏洞检查工具检查系统相关漏洞（即用最专业的黑客攻击工具攻击试一下，现在最常用的是 NBSI 系列和 IPhacker IP ） 、采用各种木马检查工具检查系统木马情况 、采用各种防外挂工具检查系统各组程序的外挂漏洞 数据库安全考虑问题： 系统数据是否机密（比如对银行系统，这一点就特别重要，一般的网站就没有太高要求）、系统数据的完整性（我刚刚结束的企业实名核查服务系统中就曾存在数据 的不完整，对于这个系统的功能实现有了障碍） 、系统数据可管理性 、系统数据的独立性 、系统数据可备份和恢复能力（数据备份是否完整，可否恢复，恢复是否可以完整） 12、什么是测试用例 什么是测试脚本 两者的关系是什么？ 为实施测试而向被测试系统提供的输入数据、操作或各种环境设置以及期望结果的一个特定的集合。 测试脚本是为了进行自动化测试而编写的脚本。 测试脚本的编写必须对应相应的测试用例 13、简述什么是静态测试、动态测试、黑盒测试、白盒测试、α测试 β测试 静态测试是不运行程序本身而寻找程序代码中可能存在的错误或评估程序代码的过程。 动态测试是实际运行被测程序，输入相应的测试实例，检查运行结果与预期结果的差异，判定执行结果是否符合要求，从而检验程序的正确性、可靠性和有效性，并分析系统运行效率和健壮性等性能。 黑盒测试一般用来确认软件功能的正确性和可操作性,目的是检测软件的各个功能是否能得以实现,把被测试的程序当作一个黑盒,不考虑其内部结构,在知道该程序的输入和输出之间的关系或程序功能的情况下,依靠软件规格说明书来确定测试用例和推断测试结果的正确性。 白盒测试根据软件内部的逻辑结构分析来进行测试,是基于代码的测试，测试人员通过阅读程序代码或者通过使用开发工具中的单步调试来判断软件的质量，一般黑盒测试由项目经理在程序员开发中来实现。 α测试是由一个用户在开发环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由程序员或测试员完成。 β测试是软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。 14、软件质量保证体系是什么 国家标准中与质量保证管理相关的几个标准是什么?他们的编号和全称是什么? SQA由一套软件工程过程和方法组成，以保证（软件的）质量。SQA贯穿整个软件开发过程，(它)应包括需求文档评审、代码控制、代码评审、变更管理、配置管理、版本管理和软件测试。 软件质量保证（ SQA -Software Quality Assurance）是建立一套有计划，有系统的方法，来向管理层保证拟定出的标准、步骤、实践和方法能够正确地被所有项目所采用。软件质量保证的目的是使软件过程对于管理人员来说是可见的。它通过对软件产品和活动进行评审和审计来验证软件是合乎标准的。软件质量保证组在项目开始时就一起参与建立计划、标准和过程。这些将使软件项目满足机构方针的要求。 15、软件产品质量特性是什么? 功能性：适应性、准确性、互操作性、依从性、安全性。 可靠性：成熟性、容错性、易恢复性。 可使用性：易理解性、易学习性、易操作性。 效率：时间特性、资源特性。 可维护性：易分析性、易变更性、稳定性、易测试性。 可移植性： 适应性、易安装性、遵循性、易替换性 16、软件测试的策略是什么? 软件测试策略：在一定的软件测试标准、测试规范的指导下，依据测试项目的特定环境约束而规定的软件测试的原则、方式、方法的集合。 17、软件测试分为几个阶段 各阶段的测试策略和要求是什么? 和开发过程相对应，测试过程会依次经历单元测试、集成测试、系统测试、验收测试四个主要阶段： 单元测试：单元测试是针对软件设计的最小单位––程序模块甚至代码段进行正确性检验的测试工作，通常由开发人员进行。 集成测试：集成测试是将模块按照设计要求组装起来进行测试，主要目的是发现与接口有关的问题。由于在产品提交到测试部门前，产品开发小组都要进行联合调试，因此在大部分企业中集成测试是由开发人员来完成的。 系统测试：系统测试是在集成测试通过后进行的，目的是充分运行系统，验证各子系统是否都能正常工作并完成设计的要求。它主要由测试部门进行，是测试部门最大最重要的一个测试，对产品的质量有重大的影响。 验收测试：验收测试以需求阶段的《需求规格说明书》为验收标准，测试时要求模拟实际用户的运行环境。对于实际项目可以和客户共同进行，对于产品来说就是最后一次的系统测试。测试内容为对功能模块的全面测试，尤其要进行文档测试。 单元测试测试策略： 自顶向下的单元测试策略：比孤立单元测试的成本高很多，不是单元测试的一个好的选择。 自底向上的单元测试策略：比较合理的单元测试策略，但测试周期较长。 孤立单元测试策略：最好的单元测试策略。 集成测试的测试策略： 大爆炸集成：适应于一个维护型项目或被测试系统较小 自顶向下集成：适应于产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。 自底向上集成：适应于底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。 基于进度的集成 优点：具有较高的并行度；能够有效缩短项目的开发进度。 缺点：桩和驱动工作量较大；有些接口测试不充分；有些测试重复和浪费。 系统测试的测试策略： 数据和数据库完整性测试；功能测试；用户界面测试；性能评测；负载测试；强度测试；容量测试；安全性和访问控制测试；故障转移和恢复测试；配置测试；安装测试；加密测试；可用性测试；版本验证测试；文档测试 18、软件测试各个阶段通常完成什么工作？各个阶段的结果文件是什么？包括什么内容？ 单元测试阶段：各独立单元模块在与系统地其他部分相隔离的情况下进行测试，单元测试针对每一个程序模块进行正确性校验，检查各个程序模块是否正确地实现了规定的功能。生成单元测试报告，提交缺陷报告。 集成测试阶段：集成测试是在单元测试的基础上，测试在将所有的软件单元按照概要设计规格说明的要求组装成模块、子系统或系统的过程中各部分工作是否达到或实现相应技术指标及要求的活动。该阶段生成集成测试报告，提交缺陷报告。 系统测试阶段：将通过确认测试的软件，作为整个给予计算机系统的一个元素，与计算机硬件、外设、某些支持软件、数据和人员等其他系统元素结合在一起，在实际运行环境下，对计算机系统进行全面的功能覆盖。该阶段需要提交测试总结和缺陷报告。 19、测试人员在软件开发过程中的任务是什么？ 1、尽可能早的找出系统中的Bug； 2、避免软件开发过程中缺陷的出现； 3、衡量软件的品质，保证系统的质量； 4、关注用户的需求，并保证系统符合用户需求。 总的目标是：确保软件的质量。 20、在您以往的工作中，一条软件缺陷（或者叫Bug）记录都包含了哪些内容？如何提交高质量的软件缺陷（Bug）记录？ 一条Bug记录最基本应包含： bug编号； bug严重级别，优先级； bug产生的模块； 首先要有bug摘要，阐述bug大体的内容； bug对应的版本； bug详细现象描述，包括一些截图、录像….等等； bug出现时的测试环境，产生的条件即对应操作步骤； 高质量的Bug记录： 1) 通用UI要统一、准确 缺陷报告的UI要与测试的软件UI保持一致，便于查找定位。 2) 尽量使用业界惯用的表达术语和表达方法 使用业界惯用的表达术语和表达方法，保证表达准确，体现专业化。 3) 每条缺陷报告只包括一个缺陷 每条缺陷报告只包括一个缺陷，可以使缺陷修正者迅速定位一个缺陷，集中精力每次只修正一个缺陷。校验者每次只校验一个缺陷是否已经正确修正。 4) 不可重现的缺陷也要报告 首先缺陷报告必须展示重现缺陷的能力。不可重现的缺陷要尽力重现，若尽力之后仍不能重现，仍然要报告此缺陷，但在报告中要注明无法再现，缺陷出现的频率。 5) 明确指明缺陷类型 根据缺陷的现象，总结判断缺陷的类型。例如，即功能缺陷、界面缺陷、数据缺陷，合理化建议这是最常见的缺陷或缺陷类型，其他形式的缺陷或缺陷也从属于其中某种形式。 6) 明确指明缺陷严重等级和优先等级 时刻明确严重等级和优先等级之间的差别。高严重问题可能不值得解决，小装饰性问题可能被当作高优先级。 7) 描述 (Description) ，简洁、准确，完整，揭示缺陷实质，记录缺陷或缺陷出现的位置 描述要准确反映缺陷的本质内容，简短明了。为了便于在软件缺陷管理数据库中寻找制定的测试缺陷，包含缺陷发生时的用户界面（ UI ）是个良好的习惯。例如记录对话框的标题、菜单、按钮等控件的名称。 8) 短行之间使用自动数字序号，使用相同的字体、字号、行间距 短行之间使用自动数字序号，使用相同的字体、字号、行间距，可以保证各条记录格式一致，做到规范专业。 9) 每一个步骤尽量只记录一个操作 保证简洁、条理井然，容易重复操作步骤。 10) 确认步骤完整，准确，简短 保证快速准确的重复缺陷，\"完整\"即没有缺漏，\"准确\"即步骤正确，\"简短\"即没有多余的步骤。 11) 根据缺陷，可选择是否进行图象捕捉 为了直观的观察缺陷或缺陷现象，通常需要附加缺陷或缺陷出现的界面，以图片的形式作为附件附着在记录的\"附件\"部分。为了节省空间，又能真实反映缺陷或缺陷本质，可以捕捉缺陷或缺陷产生时的全屏幕，活动窗口和局部区域。为了迅速定位、修正缺陷或缺陷位置，通常要求附加中文对照图。  附加必要的特殊文档和个人建议和注解 如果打开某个特殊的文档而产生的缺陷或缺陷，则必须附加该文档，从而可以迅速再现缺陷或缺陷。有时，为了使缺陷或缺陷修正者进一步明确缺陷或缺陷的表现，可以附加个人的修改建议或注解。 12) 检查拼写和语法缺陷 在提交每条缺陷或缺陷之前，检查拼写和语法，确保内容正确，正确的描述缺陷。 13) 尽量使用短语和短句，避免复杂句型句式 软件缺陷管理数据库的目的是便于定位缺陷，因此，要求客观的描述操作步骤，不需要修饰性的词汇和复杂的句型，增强可读性。 以上概括了报告测试缺陷的规范要求，随着软件的测试要求不同，测试者经过长期测试，积累了相应的测试经验，将会逐渐养成良好的专业习惯，不断补充新的规范书写要求。此外，经常阅读、学习其他测试工程师的测试缺陷报告，结合自己以前的测试缺陷报告进行对比和思考，可以不断提高技巧。 14) 缺陷描述内容 缺陷描述的内容可以包含缺陷操作步骤，实际结果和期望结果。操作步骤可以方便开发人员再现缺陷进行修正，有些开发的再现缺陷能力很差，虽然他明白你所指的缺陷，但就是无法再现特别是对系统不熟悉的新加入开发人员，介绍步骤可以方便他们再现。实际结果可以让开发明白错误是什么，期望结果可以让开发了解正确的结果应该是如何。 21、黑盒测试和白盒测试是软件测试的两种基本方法，请分别说明各自的优点和缺点！ 黑盒测试的优点有：比较简单，不需要了解程序内部的代码及实现；与软件的内部实现无关； 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题；基于软件开发文档，所以也能知道软件实现了文档中的哪些功能；在做软件自动化测试时较为方便。 黑盒测试的缺点有：不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%；自动化测试的复用性较低。 白盒测试的优点有：帮助软件测试人员增大代码的覆盖率，提高代码的质量，发现代码中隐 藏的问题。 白盒测试的缺点有：程序运行会有很多不同的路径，不可能测试所有的运行路径；测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；系统庞大时，测试开销会非常大。 22、如何测试一个纸杯？ 功能度：用水杯装水看漏不漏；水能不能被喝到 安全性：杯子有没有毒或细菌 可靠性：杯子从不同高度落下的损坏程度 可移植性：杯子在不同的地方、温度等环境下是否都可以正常使用 兼容性：杯子是否能够容纳果汁、白水、酒精、汽油等 易用性：杯子是否烫手、是否有防滑措施、是否方便饮用 用户文档：使用手册是否对杯子的用法、限制、使用条件等有详细描述 疲劳测试：将杯子盛上水（案例一）放24小时检查泄漏时间和情况；盛上汽油（案例二）放24小时检查泄漏时间和情况等 压力测试：用根针并在针上面不断加重量，看压强多大时会穿透 22、测试计划工作的目的是什么？测试计划文档的内容应该包括什么？其中哪些是最重要的？ 软件测试计划是指导测试过程的纲领性文件： 领导能够根据测试计划进行宏观调控，进行相应资源配置等 测试人员能够了解整个项目测试情况以及项目测试不同阶段的所要进行的工作等 便于其他人员了解测试人员的工作内容，进行有关配合工作 包含了产品概述、测试策略、测试方法、测试区域、测试配置、测试周期、测试资源、测试交流、风险分析等内容。借助软件测试计划，参与测试的项目成员，尤其是测试管理人员，可以明确测试任务和测试方法，保持测试实施过程的顺畅沟通，跟踪和控制测试进度，应对测试过程中的各种变更。 测试计划编写6要素（ 5W1H ）： why——为什么要进行这些测试； what—测试哪些方面，不同阶段的工作内容； when—测试不同阶段的起止时间； where—相应文档，缺陷的存放位置，测试环境等； who—项目有关人员组成，安排哪些测试人员进行测试； how—如何去做，使用哪些测试工具以及测试方法进行测试 测试计划和测试详细规格、测试用例之间是战略和战术的关系，测试计划主要从宏观上规划测试活动的范围、方法和资源配置，而测试详细规格、测试用例是完成测试任务的具体战术。所以其中最重要的是测试测试策略和测试方法（最好是能先评审）。 23、黑盒测试的测试用例常见设计方法都有哪些？请分别以具体的例子来说明这些方法在测试用例设计工作中的应用。 1）等价类划分： 等价类是指某个输入域的子集合.在该子集合中,各个输入数据对于揭露程序中的错误都是等效的.并合理地假定:测试某等价类的代表值就等于对这一类其它值的测试.因此,可以把全部输入数据合理划分为若干等价类,在每一个等价类中取一个数据作为测试的输入条件,就可以用少量代表性的测试数据.取得较好的测试结果.等价类划分可有两种不同的情况:有效等价类和无效等价类. 2）边界值分析法：是对等价类划分方法的补充。测试工作经验告诉我,大量的错误是发生在输入或输出范围的边界上,而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例,可以查出更多的错误. 使用边界值分析方法设计测试用例,首先应确定边界情况.通常输入和输出等价类的边界,就是应着重测试的边界情况.应当选取正好等于,刚刚大于或刚刚小于边界的值作为测试数据,而不是选取等价类中的典型值或任意值作为测试数据. 3）错误猜测法：基于经验和直觉推测程序中所有可能存在的各种错误, 从而有针对性的设计测试用例的方法. 错误推测方法的基本思想: 列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例. 例如, 在单元测试时曾列出的许多在模块中常见的错误. 以前产品测试中曾经发现的错误等, 这些就是经验的总结. 还有, 输入数据和输出数据为0的情况. 输入表格为空格或输入表格只有一行. 这些都是容易发生错误的情况. 可选择这些情况下的例子作为测试用例. 4）因果图方法：前面介绍的等价类划分方法和边界值分析方法,都是着重考虑输入条件,但未考虑输入条件之间的联系, 相互组合等. 考虑输入条件之间的相互组合,可能会产生一些新的情况. 但要检查输入条件的组合不是一件容易的事情, 即使把所有输入条件划分成等价类,他们之间的组合情况也相当多. 因此必须考虑采用一种适合于描述对于多种条件的组合,相应产生多个动作的形式来考虑设计测试用例. 这就需要利用因果图（逻辑模型）. 因果图方法最终生成的就是判定表. 它适合于检查程序输入条件的各种组合情况. 5）正交表分析法：可能因为大量的参数的组合而引起测试用例数量上的激增，同时，这些测试用例并没有明显的优先级上的差距，而测试人员又无法完成这么多数量的测试，就可以通过正交表来进行缩减一些用例，从而达到尽量少的用例覆盖尽量大的范围的可能性。 6）场景分析方法：指根据用户场景来模拟用户的操作步骤，这个比较类似因果图，但是可能执行的深度和可行性更好。 7）状态图法：通过输入条件和系统需求说明得到被测系统的所有状态，通过输入条件和状态得出输出条件；通过输入条件、输出条件和状态得出被测系统的测试用例。 8）大纲法：大纲法是一种着眼于需求的方法，为了列出各种测试条件，就将需求转换为大纲的形式。大纲表示为树状结构，在根和每个叶子结点之间存在唯一的路径。大纲中的每条路径定义了一个特定的输入条件集合，用于定义测试用例。树中叶子的数目或大纲中的路径给出了测试所有功能所需测试用例的大致数量。 24、详细的描述一个测试活动完整的过程。（供参考，本答案主要是瀑布模型的做法） 项目经理通过和客户的交流，完成需求文档，由开发人员和测试人员共同完成需求文档的评审，评审的内容包括：需求描述不清楚的地方和可能有明显冲突或者无法实现的功能的地方。项目经理通过综合开发人员，测试人员以及客户的意见，完成项目计划。然后SQA进入项目，开始进行统计和跟踪 开发人员根据需求文档完成需求分析文档，测试人员进行评审，评审的主要内容包括是否有遗漏或双方理解不同的地方。测试人员完成测试计划文档，测试计划包括的内容上面有描述。 测试人员根据修改好的需求分析文档开始写测试用例，同时开发人员完成概要设计文档，详细设计文档。此两份文档成为测试人员撰写测试用例的补充材料。 测试用例完成后，测试和开发需要进行评审。 测试人员搭建环境 开发人员提交第一个版本，可能存在未完成功能，需要说明。测试人员进行测试，发现BUG后提交给BugZilla。 开发提交第二个版本，包括Bug Fix以及增加了部分功能，测试人员进行测试。 重复上面的工作，一般是3-4个版本后BUG数量减少，达到出货的要求。 如果有客户反馈的问题，需要测试人员协助重现并重新测试。 26、BUG管理工具的跟踪过程（用BugZilla为例子） 测试人员发现了BUG，提交到Bugzilla中，状态为new，BUG的接受者为开发接口人员 开发接口将BUG分配给相关的模块的开发人员，状态修改为已分配，开发人员和测试确认BUG，如果是本人的BUG，则设置为接收；如果是别的开发人员的问题，则转发出去，由下一个开发人员来进行此行为；如果认为不是问题，则需要大家讨论并确认后，拒绝这个BUG，然后测试人员关闭此问题。 如果开发人员接受了BUG，并修改好以后，将BUG状态修改为已修复，并告知测试在哪个版本中可以测试。 测试人员在新版本中测试，如果发现问题依然存在，则拒绝验证；如果已经修复，则关闭BUG。 27、您认为在测试人员同开发人员的沟通过程中，如何提高沟通的效率和改善沟通的效果？维持测试人员同开发团队中其他成员良好的人际关系的关键是什么？ 尽量面对面的沟通，其次是能直接通过电话沟通，如果只能通过Email等非及时沟通工具的话，强调必须对特性的理解深刻以及能表达清楚。 运用一些测试管理工具如TestDirector进行管理也是较有效的方法，同时要注意在TestDirector中对BUG有准确的描述。 在团队中建立测试人员与开发人员良好沟通中注意以下几点： 一真诚、二是团队精神、三是在专业上有共同语言、四是要对事不对人，工作至上 当然也可以通过直接指出一些小问题，而不是进入BUG Tracking System来增加对方的好感。 28、你对测试最大的兴趣在哪里？为什么？ 回答这个面试题，没有固定统一的答案，但可能是许多企业都会问到的。提供以下答案供考： 最大的兴趣，感觉这是一个有挑战性的工作； 测试是一个经验行业，工作越久越能感觉到做好测试的难度和乐趣 通过自己的工作，能使软件产品越来越完善，从中体会到乐趣 回答此类问题注意以下几个方面： 尽可能的切合招聘企业的技术路线来表达你的兴趣，例如该企业是数据库应用的企业，那么表示你的兴趣在数据库的测试，并且希望通过测试提升自己的数据库掌握能力。 表明你做测试的目的是为了提升能力，也是为了更好的做好测试；提升能力不是为了以后转开发或其他的，除非用人企业有这样的安排。 不要过多的表达你的兴趣在招聘企业的范畴这外。比如招聘企业是做财务软件的，可是你表现出来的是对游戏软件的兴趣；或招聘是做JAVA开发的，而你的兴趣是在C类语言程序的开发。 29、你自认为测试的优势在哪里？ 该面试也没有固定不变的答案，但可参考以下几点，并结合自身特点： 有韧性、有耐心、做事有条理性、喜欢面对挑战、有信心做好每一件事情、较强的沟通能力、从以前的经理处都得到了很好的评价表明我做的很好 33、简述你在以前的工作中做过哪些事情，比较熟悉什么。参考答案如下。 我过去的主要工作是系统测试和自动化测试。在系统测试中，主要是对BOSS系统的业务逻辑功能，以及软交换系统的Class 5特性进行测试。性能测试中，主要是进行的压力测试，在各个不同数量请求的情况下，获取系统响应时间以及系统资源消耗情况。自动化测试主要是通过自己写脚本以及一些第三方工具的结合来测试软交换的特性测试。 在测试中，我感觉对用户需求的完全准确的理解非常重要。另外，就是对BUG的管理，要以需求为依据，并不是所有BUG均需要修改。 测试工作需要耐心和细致，因为在新版本中，虽然多数原来发现的BUG得到了修复，但原来正确的功能也可能变得不正确。因此要注重迭代测试和回归测试。 34、在C/C++中static有什么用途？（请至少说明两种） 1)在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用 35、引用与指针有什么区别？ 1) 引用必须被初始化，指针不必。 2) 引用初始化以后不能被改变，指针可以改变所指的对象。 3) 不存在指向空值的引用，但是存在指向空值的指针。 36、Internet采用哪种网络协议？该协议的主要层次结构？Internet物理地址和IP地址转换采用什么协议？ TCP /IP协议主要层次结构为： 应用层/传输层/网络层/数链路层。 ARP (Address Resolution Protocol)（地据址解析协议） 37、说说你对集成测试中自顶向下集成和自底向上集成两个策略的理解，要谈出它们各自的优缺点和主要适应于哪种类型测试； 自顶向下集成 优点：较早地验证了主要控制和判断点；按深度优先可以首先实现和验证一个完整的软件功能；功能较早证实，带来信心；只需一个驱动，减少驱动器开发的费用；支持故障隔离。 缺点：柱的开发量大；底层验证被推迟；底层组件测试不充分。 适应于产品控制结构比较清晰和稳定；高层接口变化较小；底层接口未定义或经常可能被修改；产口控制组件具有较大的技术风险，需要尽早被验证；希望尽早能看到产品的系统功能行为。 2、自底向上集成 优点：对底层组件行为较早验证；工作最初可以并行集成，比自顶向下效率高；减少了桩的工作量；支持故障隔离。 缺点：驱动的开发工作量大；对高层的验证被推迟，设计上的错误不能被及时发现。 适应于底层接口比较稳定；高层接口变化比较频繁；底层组件较早被完成。 38、软件验收测试包括正式验收测试、alpha测试、beta测试三种测试。 39、系统测试的策略有很多种的，有性能测试、负载测试、强度测试、易用性测试、安全测试、配置测试、安装测试、文档测试、故障恢复测试、用户界面测试、恢复测试、分布测试、可用性测试。 40、设计系统测试计划需要参考的项目文档有软件测试计划、软件需求工件、和迭代计划 41．通过画因果图来写测试用例的步骤为 、 、 、 及把因果图转换为状态图共五个步骤。 利用因果图生成测试用例的基本步骤是： § 分析软件规格说明描述中，哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符。 § 分析软件规格说明描述中的语义，找出原因与结果之间，原因与原因之间对应的是什么关系? 根据这些关系，画出因果图。 § 由于语法或环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号标明约束或限制条件。 § 把因果图转换成判定表。 § 把判定表的每一列拿出来作为依据，设计测试用例。 43、请说出这些测试最好由那些人员完成，测试的是什么？ 代码、函数级测试一般由白盒测试人员完成，他们针对每段代码或函数进行正确性检验，检查其是否正确的实现了规定的功能。 模块、组件级测试主要依据是程序结构设计测试模块间的集成和调用关系，一般由测试人员完成。 系统测试在于模块测试与单元测试的基础上进行测试。了解系统功能与性能，根据测试用例进行全面的测试。 44、 设计测试用例时应该考虑哪些方面，即不同的测试用例针对那些方面进行测试？ 设计测试用例时需要注意的是，除了对整体流程及功能注意外，还要注意强度测试、性能测试、压力测试、边界值测试、稳定性测试、安全性测试等多方面。（测试用例需要考虑的四个基本要素是输入、输出、操作和测试环境；另外，测试用例需要考虑的是测试类型（功能、性能、安全……），这部分可以参照TP做答。此外，还需要考虑用例的重要性和优先级） 45、 在windows下保存一个文本文件时会弹出保存对话框，如果为文件名建立测试用例，等价类应该怎样划分？ 单字节，如A；双字节， AA 、我我；特殊字符 /‘。‘；、=-等；保留字，如com；文件格式为8.3格式的；文件名格式为非8.3格式的；/,\\,*等九个特殊字符。 46、假设有一个文本框要求输入10个字符的邮政编码，对于该文本框应该怎样划分等价类？ 特殊字符，如10个*或￥；英文字母，如ABCDefghik；小于十个字符，如123；大于十个字符，如11111111111；数字和其他混合，如123AAAAAAA；空字符；保留字符 47.软件测试项目从什么时候开始，？为什么？ 软件测试应该在需求分析阶段就介入,因为测试的对象不仅仅是程序编码,应该对软件开发过程中产生的所有产品都测试,并且软件缺陷存在放大趋势.缺陷发现的越晚,修复它所花费的成本就越大. 48、什么是回归测试? 回归测试: (regression testing): 回归测试有两类：用例回归和错误回归；用例回归是过一段时间以后再回头对以前使用过的用例在重新进行测试，看看会重新发现问题。错误回归，就是在新版本中，对以前版本中出现并修复的缺陷进行再次验证，并以缺陷为核心，对相关修改的部分进行测试的方法。 49.单元测试、集成测试、系统测试的侧重点是什么？ 单元测试针对的是软件设计的最小单元–程序模块（面向过程中是函数、过程；面向对象中是类。）,进行正确性检验的测试工作,在于发现每个程序模块内部可能存在的差错.一般有两个步骤:人工静态检查\\动态执行跟踪 集成测试针对的是通过了单元测试的各个模块所集成起来的组件进行检验,其主要内容是各个单元模块之间的接口,以及各个模块集成后所实现的功能. 系统测试针对的是集成好的软件系统，作为整个计算机系统的一个元素,与计算机硬件\\外设\\某些支持软件\\数据和人员等其他系统元素结合在一起,要在实际的运行环境中,对计算机系统进行一系列的集成测试和确认测试. 51.一个测试工程师应具备那些素质？ 1、责任心2、沟通能力3、团队合作精神4、耐心、细心、信心5、时时保持怀疑态度，并且有缺陷预防的意识6、具备一定的编程经验 53：你所了解的的软件测试类型都有哪些，简单介绍一下。 按测试策略分类：1、静态与动态测试2、黑盒与白盒测试 3、手工和自动测试 4、冒烟测试 5、回归测试； 按测试阶段分类：单元测试、集成测试、系统测试； 其他常见测试方法：1、功能测试 2、性能测试 3、压力测试 4、负载测试 5、易用性测试 6、安装测试 7、界面测试 8、配置测试 9、文档测试 10、兼容性测试 11、安全性测试 12、恢复测试 54：你认为做好测试计划工作的关键是什么？ 明确测试的目标，增强测试计划的实用性 编写软件测试计划得重要目的就是使测试过程能够发现更多的软件缺陷，因此软件测试计划的价值取决于它对帮助管理测试项目，并且找出软件潜在的缺陷。因此，软件测试计划中的测试范围必须高度覆盖功能需求，测试方法必须切实可行，测试工具并且具有较高的实用性，便于使用，生成的测试结果直观、准确 坚持\"5W\"规则，明确内容与过程 \"5W\"规则指的是\"What（做什么）\"、\"Why（为什么做）\"、\"When（何时做）\"、\"Where（在哪里）\"、\"How（如何做）\"。利用\"5W\"规则创建软件测试计划，可以帮助测试团队理解测试的目的（Why），明确测试的范围和内容（What），确定测试的开始和结束日期（When），指出测试的方法和工具（How），给出测试文档和软件的存放位置（Where）。 采用评审和更新机制，保证测试计划满足实际需求 测试计划写作完成后，如果没有经过评审，直接发送给测试团队，测试计划内容的可能不准确或遗漏测试内容，或者软件需求变更引起测试范围的增减，而测试计划的内容没有及时更新，误导测试执行人员。 分别创建测试计划与测试详细规格、测试用例 应把详细的测试技术指标包含到独立创建的测试详细规格文档，把用于指导测试小组执行测试过程的测试用例放到独立创建的测试用例文档或测试用例管理数据库中。测试计划和测试详细规格、测试用例之间是战略和战术的关系，测试计划主要从宏观上规划测试活动的范围、方法和资源配置，而测试详细规格、测试用例是完成测试任务的具体战术。 55：您认为做好测试用例设计工作的关键是什么？ 白盒测试用例设计的关键是以较少的用例覆盖尽可能多的内部程序逻辑结果 黑盒法用例设计的关键同样也是以较少的用例覆盖模块输出和输入接口。不可能做到完全测试，以最少的用例在合理的时间内发现最多的问题 56：你的测试职业发展目标是什么？ 测试经验越多，测试能力越高。所以我的职业发展是需要时间累积的，一步步向着高级测试工程师奔去。而且我也有初步的职业规划，前3年累积测试经验，不断的更新自己改正自己，做好测试任务。 57：测试结束的标准是什么？ 从微观上来说，在测试计划中定义，比如系统在一定性能下平稳运行72小时，目前Bug Tracking System中，本版本中没有一般严重的BUG，普通BUG的数量在3以下，BUG修复率90%以上等等参数，然后由开发经理，测试经理，项目经理共同签字认同版本Release。 如果说宏观的，则是当这个软件彻底的消失以后，测试就结束了。 59、一套完整的测试应该由哪些阶段组成？ 可行性分析、需求分析、概要设计、详细设计、编码、单元测试、集成测试、系统测试、验收测试 61、您是否了解以往所工作的企业的软件开发过程？如果了解，请试述一个完整的开发过程需要完成哪些工作？分别由哪些不同的角色来完成这些工作？您在以往的测试工作中都曾经具体从事过哪些工作？其中最擅长哪部分工作？ 开发过程—需求调研（需求人员）、需求分析（需求人员）、概要设计（设计人员）、详细设计(设计人员)、编码（开发人员） 测试过程—需求评审、系统测试设计、概要设计评审、集成测试设计、详细设计评审、单元测试设计、测试执行 测试工作的整个过程都做过，擅长做测试设计 过程决定质量，软件的过程改进正是为了提高软件的质量，将过往的种种经验教训积累起来。 62、测试用例设计的原则是什么？目前主要的测试用例设计方法有哪些？ 代表性：能够代表并覆盖各种合理的和不合理、合法的和非法的、边界的和越界的、以及极限的输入数据、操作和环境设置等. 可判定性：即测试执行结果的正确性是可判定的，每一个测试用例都应有相应的期望结果. 可再现性：即对同样的测试用例，系统的执行结果应当是相同的。 方法有等价类、边界值、因果图、状态图、正交法、大纲法 63、面向对象的测试用例设计有几种方法？如何实现？ 给类中的每个构造函数设计一组测试用例 组合类中的类变量、实例变量 组合类中的各种方法 根据前置条件和后置条件设计测试用例 根据代码设计测试用例 64、LoadRunner分为哪三个模块？请简述各模块的主要功能。 Virtual User Generator：用于录制脚步 Mercury LoadRunner Controller：用于创建、运行和监控场景 Mercury LoadRunner Analysis：用于分析测试结果 65、你对测试最大的兴趣在哪里？为什么？ 最大的兴趣就是测试有难度，有挑战性！做测试越久越能感觉到做好测试有多难。曾经在无忧测试网上看到一篇文章，是关于如何做好一名测试工程师。一共罗列了11，12点，有部分是和人的性格有关，有部分需要后天的努力。但除了性格有关的1，2点我没有把握，其他点我都很有信心做好它。 刚开始进入测试行业时，对测试的认识是从无忧测试网上了解到的一些资料，当时是冲着做测试需要很多技能才能做的好，虽然入门容易，但做好很难，比开发更难，虽然当时我很想做开发（学校专业课我基本上不缺席，因为我喜欢我的专业），但看到测试比开发更难更有挑战性，想做好测试的意志就更坚定了。 我觉得做测试整个过程中有2点让我觉得很有难度（对我来说，有难度的东西我就非常感兴趣），第一是测试用例的设计，因为测试的精华就在测试用例的设计上了，要在版本出来之前，把用例写好，用什么测试方法写？（也就是测试计划或测试策略），如果你刚测试一个新任务时，你得花一定的时间去消化业务需求和技术基础，业务需求很好理解（多和产品经理和开发人员沟通就能达到目的），而技术基础可就没那么简单了，这需要你自觉的学习能力，比如说网站吧，最基本的技术知识你要知道网站内部是怎么运作的的，后台是怎么响应用户请求的？测试环境如何搭建？这些都需要最早的学好。至少在开始测试之前能做好基本的准备，可能会遇到什么难题？需求细节是不是没有确定好？这些问题都能在设计用例的时候发现。 第二是发现BUG的时候了，这应该是测试人员最基本的任务了，一般按测试用例开始测试就能发现大部分的bug，还有一部分bug需要测试的过程中更了解所测版本的情况获得更多信息，补充测试用例，测试出bug。还有如何发现bug？这就需要在测试用例有效的情况下，通过细心和耐心去发现bug了，每个用例都有可能发现bug，每个地方都有可能出错，所以测试过程中思维要清晰（测试过程数据流及结果都得看仔细了，bug都在里面发现的）。如何描述bug也很有讲究，bug在什么情况下会产生，如果条件变化一点点，就不会有这个bug，以哪些最少的操作步骤就能重现这个bug，这个bug产生的规律是什么？如果你够厉害的话，可以帮开发人员初步定位问题。 66、您所熟悉的软件测试类型都有哪些？请试着分别比较这些不同的测试类型的区别与联系（如功能测试、性能测试……） 测试类型有：功能测试，性能测试，界面测试。 功能测试在测试工作中占的比例最大，功能测试也叫黑盒测试。是把测试对象看作一个黑盒子。利用黑盒测试法进行动态测试时，需要测试软件产品的功能，不需测试软件产品的内部结构和处理过程。采用黑盒技术设计测试用例的方法有：等价类划分、边界值分析、错误推测、因果图和综合策略。 性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过确定一个系统的瓶颈或者不能接收的性能点，来获得系统能提供的最大服务级别的测试。 界面测试，界面是软件与用户交互的最直接的层，界面的好坏决定用户对软件的第一印象。而且设计良好的界面能够引导用户自己完成相应的操作，起到向导的作用。同时界面如同人的面孔，具有吸引用户的直接优势。设计合理的界面能给用户带来轻松愉悦的感受和成功的感觉，相反由于界面设计的失败，让用户有挫败感，再实用强大的功能都可能在用户的畏惧与放弃中付诸东流。 区别在于，功能测试关注产品的所有功能上，要考虑到每个细节功能，每个可能存在的功能问题。性能测试主要关注于产品整体的多用户并发下的稳定性和健壮性。界面测试更关注于用户体验上，用户使用该产品的时候是否易用，是否易懂，是否规范（快捷键之类的），是否美观（能否吸引用户的注意力），是否安全（尽量在前台避免用户无意输入无效的数据，当然考虑到体验性，不能太粗鲁的弹出警告）？做某个性能测试的时候，首先它可能是个功能点，首先要保证它的功能是没问题的，然后再考虑该功能点的性能测试 67、请试着比较一下黑盒测试、白盒测试、单元测试、集成测试、系统测试、验收测试的区别与联系。 黑盒测试：已知产品的功能设计规格，可以进行测试证明每个实现了的功能是否符合要求。 白盒测试：已知产品的内部工作过程，可以通过测试证明每种内部操作是否符合设计规格要求，所有内部成分是否以经过检查。 软件的黑盒测试意味着测试要在软件的接口处进行。这种方法是把测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。因此黑盒测试又叫功能测试或数据驱动测试。黑盒测试主要是为了发现以下几类错误： 1、是否有不正确或遗漏的功能？2、在接口上，输入是否能正确的接受？能否输出正确的结果？3、是否有数据结构错误或外部信息（例如数据文件）访问错误？4、性能上是否能够满足要求？5、是否有初始化或终止性错误？ 软件的白盒测试是对软件的过程性细节做细致的检查。这种方法是把测试对象看做一个打开的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。通过在不同点检查程序状态，确定实际状态是否与预期的状态一致。因此白盒测试又称为结构测试或逻辑驱动测试。白盒测试主要是想对程序模块进行如下检查： 1、对程序模块的所有独立的执行路径至少测试一遍。 2、对所有的逻辑判定，取\"真\"与取\"假\"的两种情况都能至少测一遍。 3、在循环的边界和运行的界限内执行循环体。 4、测试内部数据结构的有效性，等等。 单元测试（模块测试）是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件（或者场景）下某个特定函数的行为。 单元测试是由程序员自己来完成，最终受益的也是程序员自己。可以这么说，程序员有责任编写功能代码，同时也就有责任为自己的代码编写单元测试。执行单元测试，就是为了证明这段代码的行为和我们期望的一致。 集成测试（也叫组装测试，联合测试）是单元测试的逻辑扩展。它的最简单的形式是：两个已经测试过的单元组合成一个组件，并且测试它们之间的接口。从这一层意义上讲，组件是指多个单元的集成聚合。在现实方案中，许多单元组合成组件，而这些组件又聚合成程序的更大部分。方法是测试片段的组合，并最终扩展进程，将您的模块与其他组的模块一起测试。最后，将构成进程的所有模块一起测试。 系统测试是将经过测试的子系统装配成一个完整系统来测试。它是检验系统是否确实能提供系统方案说明书中指定功能的有效方法。（常见的联调测试） 系统测试的目的是对最终软件系统进行全面的测试，确保最终软件系统满足产品需求并且遵循系统设计。 验收测试是部署软件之前的最后一个测试操作。验收测试的目的是确保软件准备就绪，并且可以让最终用户将其用于执行软件的既定功能和任务。 验收测试是向未来的用户表明系统能够像预定要求那样工作。经集成测试后，已经按照设计把所有的模块组装成一个完整的软件系统，接口错误也已经基本排除了，接着就应该进一步验证软件的有效性，这就是验收测试的任务，即软件的功能性能如同用户所合理期待的那样。 68、当开发人员说不是BUG时，你如何应付？ 开发人员说不是bug，有2种情况，一是需求没有确定，所以我可以这么做，这个时候可以找来产品经理进行确认，需不需要改动，3方商量确定好后再看要不要改。二是这种情况不可能发生，所以不需要修改，这个时候，我可以先尽可能的说出是BUG的依据是什么？如果被用户发现或出了问题，会有什么不良结果？程序员可能会给你很多理由，你可以对他的解释进行反驳。如果还是不行，那我可以给这个问题提出来,跟开发经理和测试经理进行确认,如果要修改就改,如果不要修改就不改。其实有些真的不是bug，我也只是建议的方式写进TD中，如果开发人员不修改也没有大问题。如果确定是bug的话，一定要坚持自己的立场，让问题得到最后的确认。 69、为什么要在一个团队中开展软件测试工作？ 因为没有经过测试的软件很难在发布之前知道该软件的质量，就好比ISO质量认证一样，测试同样也需要质量的保证，这个时候就需要在团队中开展软件测试的工作。在测试的过程发现软件中存在的问题，及时让开发人员得知并修改问题，在即将发布时，从测试报告中得出软件的质量情况。 71、一份测试计划应该包括哪些内容？ 背景、项目简介、目的、测试范围、测试策略、人员分工、资源要求、进度计划、参考文档、常用术语、提交文档、风险分析。 72、针对于软件的行业背景，你如何理解软件的业务？ 阅读用户手册了解软件的功能和操作流程；看一些业务的专业书籍补充业务知识；如果有用户实际的数据，可以拿实际的数据进行参考；参考以前的用例和BUG报告；在使用软件的过程中多思考；多与产品经理交流。 74、如何定位测试用例的作用？ 组织性：编写、组织性、功能覆盖、重复性、跟踪、测试确认 76、什么是兼容性测试？请举例说明如何利用兼容性测试列表进行测试。 主要验证软件产品在不同版本之间的兼容性。包括向下兼容和交错兼容，向下兼容是测试软件新版本保留它早期版本功能的情况，交错兼容是验证共同存在的两个相关但不相同的产品之间的兼容性。 77、对某软件进行测试，发现在WIN98上运行得很慢，怎么判别是该软件存在问题还是其软硬件运行环境存在问题？ 看软件的运行环境要求。如果符合要求则是程序存在问题，若不符合要求则是硬件系统存在问题 78、需求测试的注意事项有哪些？ 是否使用了公司的模板、文档内容是否符合规范、所有的需求是分级是否清析适当、所有的需求是否具有一致性、需求是否可行（即，该需求组合有解决方案）、需求可否用己知的约束来实现、需求是否足够（即，可以把它送到一个规范的开发组织，并有一个生产出所需要产品的合理的可能性）、所有的其它需求是交叉引用是否正确、用户描述是否清楚、是否用客户的语言来描述需求、每个需求描述是否清楚没有岐义，可以移交给一个独立的组去实现时也能理解、是否所有的需求都是可验证的、是否每条需求都具有独立性，即使发生了变化也不会影响其它需求、性能指标是否明确、非功能性需求是否得到充分表现、是否完整列出适用的标准或协议、标准和协议之间是否存在冲突 81、主键、外键的作用，索引的优点与不足? 答：主键：是表中的唯一标示键。作用：保证实体的完整性;加快数据库的操作速度;增加新的表记录时，数据库会自动检索新记录的主键值，不允许该值与其他表中记录的主键重复;数据库会按主键值的顺序显示记录，如果没有设定主键，则按输入的顺序显示记录。 外键：是主键的从属，表示了两个表之间的联系。作用：使用外键可以避免冗余。 索引的优点： 1、通过创建唯一性的索引，可以保证表中数据的唯一性; 2、加速数据的检索速度; 3、加快表与表之间的连接; 4、在使用分组与排序数据检索时，可以显著检索分组与排序的时间; 5、在查询的过程中使用优化隐藏器，提供系统性能。 缺点： 1、创建索引需要时间，且随着数据量的增加而增加; 2、索引需要占用物理空间; 3、当对表中数据进行修改时，索引也要动态维护，降低了数据的维护速度。 84、性能测试的流程? 1.测试需求分析2.测试计划制定与评审3.测试用例设计与开发4.测试执行与监控5.分析测试结果6.编写性能测试报告7.测试经验总结 88、简述bug的生命周期? 1， 有效地记录BUG 2， 使用BUG模板 3， 评价BUG优先级和严重性 4， BUG的生命 5， 维护BUG数据库 89、缺陷记录应包含的内容? 缺陷标识、缺陷类型、缺陷严重程度、缺陷产生可能性、缺陷优先级、缺陷状态、缺陷起源、缺陷来源、缺陷原因; 91 您所熟悉的软件测试类型都有哪些?请试着分别比较这些不同的测试类型的区别与联系(如功能测试、性能测试……) 易用性测试-界面的友好性，操作方便性等。 功能测试-系统中功能性需求的满足 安全性测试-系统是否存在安全隐患和漏洞 性能测试-系统在大并发下的响应速度和健壮性 93、您认为做好测试计划工作的关键是什么? 了解项目或系统的业务需求 和项目经理协调好，了解项目的进度计划安排情况 95您认为做好测试用例设计工作的关键是什么? 对业务和软件需求非常清楚，可以根据需求不同选择不同的测试用例设计 96、.您以往的工作中是否曾开展过测试用例的评审工作?如果有，请描述测试用例评审的过程和评审的内容。 评审计划->预审->评审; 评审内容主要是测试用例对软件需求的覆盖程度，对于相关边界是否考虑，是否针对复杂流程准备多套测试数据，是否有专门针对非功能性需求的测试。 98.您认为性能测试工作的目的是什么?做好性能测试工作的关键是什么? 关键是测试脚本的录制，测试时候测试环境的干净。 100、.您以往所从事的软件测试工作中，是否使用了一些工具来进行软件缺陷(Bug)的管理?如果有，请结合该工具描述软件缺陷(Bug)跟踪管理的流程。 CQ ，也可以使用BugFree等免费工具。 101、.您如何看待软件过程改进?在您曾经工作过的企业中，是否有一些需要改进的东西呢?您期望的理想的测试人员的工作环境是怎样的?","tags":"SoftwareTesting","url":"articles/review-questions/"},{"title":"[面试] 2. 有关list及其方法的使用","text":"解决的问题(Python/Java的list对比学习) 排序 java采用的是 Collections 包中的两个方法: Collections.sort(list) 更复杂点可以是Collection.sort(list, new Comparator<Person>() {}) Collections.reverse(list) or list.sort(Collections.reverseOrder()) python没有array,只有list,直接使用 sort 方法即可,如果是倒序可以用reverse=True指定","tags":"Java","url":"articles/2-list-methods/"},{"title":"安装dbforge SQL 8.0","text":"安装dbforge Mysql 安装最新的dbforge Mysql: https://www.devart.com/dbforge/mysql/studio/dbforgemysql80ent.exe ,总是弹出一个错误 Application requires .NET Framework 4.5.2 or higher. currently installed version is 4.5.1 or less. . 于是我就直接到官方下载最新的. NET Frameowrk 安装,但是安装总是失败. 实在没办法看到一个论坛说的说明方法如何卸载. NET Framework 然后安装对应的版本: https://answers.microsoft.com/en-us/windows/forum/all/unable-to-install-net-framework-40-or-45-on-the/6727320a-01a3-4619-a5f2-2a684c320904 . A: Step 1: Hope your ran the same Fixit, if not then run this Microsoft Fix it 50123 Step 2: Repair the version of the . NET Framework that did not update. To do this, follow these steps: Visit the following blog post: . NET Framework Cleanup Tool User's Guide Download dotnetfx_cleanup_tool.zip from the following site: http://blogs.msdn.com/cfs-file.ashx/__key/CommunityServer-Components-PostAttachments/00-08-90-44-93/dotnetfx_5F00_cleanup_5F00_tool.zip When you are prompted, click Open, and then click Extract Now. In the files that you extracted, double-click cleanup_tool.exe. If you are prompted for an administrator password or for a confirmation, provide the password, and then clickContinue. In the Do you want to run the . NET Framework Setup Cleanup Utility? message, click Yes. Image Note This tool may be in English only, but it also works for other language versions of Windows. Click Yes to accept the license agreement. In the Product to cleanup window, click the drop-down list, select a . NET Framework version that you want to remove, and then click Cleanup Now. Image Note The cleanup tool does not let you remove the . NET Framework 2.0 in Windows Vista or later versions of Windows because the . NET Framework is installed as an operating system component. After the . NET Framework is removed, restart the computer. Download and install the following components: . NET Framework 1.1 Microsoft . NET Framework Version 1.1 Redistributable Package . NET Framework 1.1 Service Pack 1 ( SP1 ) Microsoft . NET Framework 1.1 Service Pack 1 . NET Framework 3.5 SP1 (this will also install the . NET Framework 2.0 SP2 and the . NET Framework 3.0 SP2 ) Microsoft . NET Framework 3.5 Service Pack 1 Restart the computer. Visit Windows Update again, and then check for and install updates.","tags":"SQL","url":"articles/install-dbforgesql/"},{"title":"[环境搭建] tensorflow的基础学习","text":"tensorflow 安装 这里参考的是官方的文档: Installing TensorFlow on Raspbian source 安装编译 $ sudo apt-get install - git $ sudo apt-get install python3-numpy python3-dev python3-pip python3-wheel $ git clone https://github.com/tensorflow/tensorflow $ cd tensorflow $ git checkout master 未完待续 python pip安装 Python,pip环境的搭建这里就不罗嗦了,可以参考我的另外一篇博客: python3安装 新建一个virtual environment(推荐使用 pipenv )用于存放对应的pip的包,执行如下命令: $ sudo mkdir venvBigData $ cd venBigData $ sudo apt install - y libatlas - base - dev # 安装numpy需要依赖的包 $ export PIPENV_VENV_IN_PROJECT = 1 $ pipenv shell $ pipenv install tensorflow $ python # 接下来是命令行验证tensorflow安装正确与否 $ import tensorflow as tf hello = tf . constant ( 'Hello, TensorFlow!' ) sess = tf . Session () print ( sess . run ( hello ))","tags":"Python","url":"articles/tensorflow-basic/"},{"title":"[环境搭建] MYSQL 的安装配置","text":"安装 执行如下命令进行安装和基本的配置: $ sudo apt-get -y install mysql-server $ sudo mysql_secure_installation 第二条命令将会配置mysql的 root 密码,删除掉 test 数据库,不允许匿名登录等等操作. 按照上面的操作mysql的配置是没有问题的了,但是你会发现,如果你运行如下命令: mysql -u root -p , 这里的root不用输入密码,明明上面的已经设置了密码??? 进行如下的命令进行配置: $ sudo mysql -u root -p $ use mysql ; $ update user set plugin = 'mysql_native_password' where user = 'root' ; $ flush privileges ; $ quit ; 配置 root 密码的更改,可以采用下面的操作步骤: $ sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf 增加一行代码: skip-grant-tables 参见 https://www.jb51.net/article/100925.htm $ sudo mysql -u root -p $ use mysql ; $ UPDATE mysql.user SET Password = PASSWORD ( 'YanZhi123!@#)0x&*' ) where USER = 'root' ; $ flush privileges ; 增加用户名和授权远程登录: $ sudo nano /etc/mysql/mariadb.conf.d/50-server.cnf 注释掉 bind-address = 127 .0.0.1 $ sudo mysql -u root -p $ use mysql ; $ CREATE USER 'yanzhi' @ '%' IDENTIFIED BY 'yanzhi123!@#' ; $ GRANT ALL PRIVILEGES ON *.* TO 'yanzhi' @ '%' IDENTIFIED BY 'yanzhi123!@#' ; -- 远程连接权限所有的数据库. $ flush privileges ; 创建数据库,支持中文: UTF8 : CREATE DATABASE test2 DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci 自动备份数据库,每天备份一次 * 新建文件: sudo nano /usr/sbin/mysqlbackup.sh ,内容如下: 1 2 3 4 5 6 7 8 9 #!/bin/bash # Name:mysql_backup.sh # This is a ShellScript For Auto DB Backup and Delete old Backup # backupdir = /www/backups time = ` date +%Y-%m-%d_%H%M%S ` /usr/bin/mysqldump --routines -u 'test' -p 'test!@#' pingbook | gzip > $backupdir /yanzhi $time .sql.gz # 删除七天前的备份 find $backupdir -name \"*.sql.gz\" -type f -mtime +7 -exec rm {} \\ > /dev/null 2 > & 1 添加可执行权限对应sh文件. $ sudo chmod +x /usr/sbin/mysqlbackup.sh 增加定时任务在 sudo nano /etc/crontab #创建一个mysql备份的操作 2 1 * * * root /usr/sbin/mysqlbackup.sh >> /var/log/crontab/backup.log 2>&1 重启 crontab 以便生效 sudo systemctl restart cron.service mysql startup error https://blog.csdn.net/mr_raptor/article/details/70576117 [ ERROR ] Can't init tc log innodb_empty_free_list_algorithm has been changed to legacy because of small buffer pool size. In order to use backoff, increase buffer pool at least up to 20MB . 解决方法是删除mysql的log文件,因为磁盘满了不能写log了: $ cd /var/lib/mysql $ rm -f ib_logfile* $ rm -f tc.log","tags":"树莓派","url":"articles/pi-mysql/"},{"title":"[环境搭建] 如何完整卸载python2/3 在debain上","text":"卸载 remove python3 $ sudo apt-get remove 'python3.*' 其实这里的python的包是: ` python3.5-minimal ` , ` python3.5-venv ` 安装 install python3.7 因为默认的debian仓库里面是python3.5,所以如果需要安装最新的python,按照如下步骤进行安装, 参考文档: https://unix.stackexchange.com/questions/332641/how-to-install-python-3-6 需要用到的命令如下: 安装依赖包 $ sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev $ sudo wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz $ tar xvf Python-3.7.0.tgz // 下面的步骤安装会跑测试来判定机器的性能,从而进行性能的提高 $ ./configure --enable-optimizations --with-ensurepip=install $ make -j8 $ sudo make altinstall $ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.7 50 $ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.7 50 安装pip,pipenv并设置全局可用命令 pipenv $ wget https://bootstrap.pypa.io/get-pip.py $ sudo python get-pip.py $ pip install --user pipenv /home/pi/.local/bin $ python -m site --user-base $ sudo nano ~/.profile export PATH = \" $HOME /.local/bin: $PATH \" $ sudo source ~/.profile $ pipenv --update uwsgi 配置详解 问题是我们的服务器后台部署在uwsgi上,今天突然有很大量的用户访问,结果导致了发到 uwsgi 的所有请求都是 Pending 的状态. 概念 emperor翻译为中文的意思其实就是皇帝的意思，那么既然有皇帝，那就肯定有\"臣子\"（vassals），其中\"臣子\"就是指实际运行的一个app实例，在这里就是uwsgi_test.ini配置文件了。 emperor模式开启的命令是： sudo uwsgi –emperor /path/to/vassals/ 其中，vassals文件夹里包含了各个app的配置文件，这个文件夹将会被emperor一直监视，只要有配置文件的修改或新建，app实例就会被重新加载或新建，可以通过软链接将实际项目中的配置文件链接到vassal文件夹目录下. 在文档中，emperor监视的是配置文件目录，但是问题来了，笔者希望每次Git仓库更新一次就重新启动实例，而如果这次更新并没有对配置文件进行修改，实例自然就不会重新启动了。 uwsgi是用c语言写的一个webserver，可以启动多个进程，进程里面可以启动多个线程来服务。进程分为主进程和worker进程，worker里面可以有多个线程。","tags":"树莓派","url":"articles/pi-python3/"},{"title":"[环境搭建] 大数据hadoop,spark,hbase,hive概念","text":"Hadoop、Spark、HBase、Hive 到处都在谈论大数据,感觉自己再不去学习这些最新的技术,自己就要被淘汰了.好吧我也开始学习了. AI = ML + BigData 关键字 hadoop spark hbase hive hdfs hadoop 安装 参考博客: https://www.cnblogs.com/jing1996/p/8038219.html $ sudo wget http://mirrors.shu.edu.cn/apache/hadoop/common/hadoop-3.0.3/hadoop-3.0.3.tar.gz $ tar zxvf hadoop-3.0.3.tar.gz $ cd hadoop-3.0.3/etc/hadoop $ sudo nano hadoop-env.sh 修改其中的 JAVA_HOME路径指向对应的JAVA_HOME路径 $ sudo nano core-site.xml <configuration> <property> <name> fs.defaultFS </name> <value> hdfs://localhost:9000 </value> </property> <property> <name> hadoop.tmp.dir </name> <value> /home/pi/hadoop-3.0.3/tmp </value> <description> namenode上本地的hadoop临时文件夹 </description> </property> </configuration> $ sudo nano hdfs-site.xml <configuration> <property> <name> dfs.replication </name> <value> 1 </value> </property> <property> <name> dfs.namenode.name.dir </name> <value> /home/pi/hadoop-3.0.3/dfs/name </value> <description> namenode上存储hdfs名字空间元数据 </description> </property> <property> <name> dfs.datanode.data.dir </name> <value> /home/pi/hadoop-3.0.3/hdfs/data </value> <description> datanode上数据块的物理存储位置 </description> </property> </configuration> $ sudo nano mapred-site.xml <configuration> <property> <name> mapreduce.framework.name </name> <value> yarn </value> </property> </configuration> $ sudo nano yarn-site.xml <configuration> <property> <name> yarn.nodemanager.aux-services </name> <value> mapreduce_shuffle </value> </property> </configuration> # 配置对应的环境变量 $ sudo nano /etc/profile # 配置hadoop的环境变量 export HADOOP_HOME=/home/pi/hadoop-3.0.3 EXPORT PATH= $PATH : $JAVA_HOME /bin: ${ HADOOP_HOME } /bin: ${ HADOOP_HOME } /sbin: $PATH $ sudo source /etc/profile $ sudo chown -R pi /home/pi/hadoop-3.0.3 修改权限 $ chown -R pi /home/pi/hadoop-3.0.3 基本概念 pass","tags":"Java","url":"articles/hadoop-spark-hbase-hive/"},{"title":"[树莓派] 树莓派国内镜像","text":"前因 自己在Github Page搭建了一个博客,但是不能被百度收录.也就是百度搜索不能爬取网站的内容,也就不能被国内搜索到了. 为树莓派更换国内镜像源 (2018-07-07更新: 清华的镜像源已经不能使用: Cannot initiate the connection to mirrors.tuna.tsinghua.edu.cn:80) 可用的官方镜像源: http://www.raspbian.org/RaspbianMirrors 使用管理员权限（经由sudo），编辑/etc/apt/sources.list文件。参考命令行为： $ sudo nano /etc/apt/sources.list 用#注释掉原文件内容，用以下内容取代使用上海大学或者是中科大(https://mirrors.ustc.edu.cn/archive.raspberrypi.org/)的镜像： deb https://mirrors.shu.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi deb-src https://mirrors.shu.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi 使用管理员权限（经由sudo），编辑/etc/apt/sources.list.d/raspi.list文件。参考命令行为： $ sudo nano /etc/apt/sources.list.d/raspi.list 用#注释掉原文件内容，用以下内容取代： deb https://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui deb-src https://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui 注意： 网址末尾的raspbian重复两次是必须的。因为Raspbian的仓库中除了APT软件源还包含其他代码。APT软件源不在仓库的根目录，而在raspbian/子目录下。 编辑镜像站后，请使用 sudo apt update && sudo apt upgrade -y 命令，更新软件源列表，同时检查您的编辑是否正确。 使用HTTPS可以有效避免国内运营商的缓存劫持，但需要事先安装 apt-transport-https .","tags":"树莓派","url":"articles/pi-mirrors/"},{"title":"[环境搭建] Debian安装编译和安装nginx服务器","text":"Debian安装配置nginx服务器 下载解压缩安装包 $ sudo wget https://nginx.org/download/nginx-1.15.1.tar.gz $ tar zxvf nginx-1.15.1.tar.gz 重新配置nginx的服务器名称servername和对应版本 $ cd nginx-1.15.1/ $ sudo nano src/http/ngx_http_header_filter_module.c $ sudo nano src/core/nginx.h $ sudo nano nginx-1.15.1-openbook.top.tar.gz nginx-1.15.1/ 安装对应的nginx的所有依赖的包, gcc环境, pcre, zlib and openssl $ sudo apt install build-essential -y $ wget https://ftp.pcre.org/pub/pcre/pcre-8.41.tar.gz $ tar zxvf pcre-8.41.tar.gz $ wget http://www.zlib.net/zlib-1.2.11.tar.gz $ tar -zxvf zlib-1.2.11.tar.gz $ wget https://www.openssl.org/source/openssl-1.1.0g.tar.gz $ tar zxvf openssl-1.1.0g.tar.gz $ cd openssl-1.1.0g $ ./config -Wl,--enable-new-dtags,-rpath, '$(LIBRPATH)' $ make # 大约五六分钟左右 $ sudo make install $ openssl version -a 安装nginx 参考说明文档: https://www.vultr.com/docs/how-to-compile-nginx-from-source-on-ubuntu-16-04 $ cd nginx-1.15.1 $ ./configure --prefix = /usr/local/nginx \\ --sbin-path = /usr/sbin/nginx \\ --modules-path = /usr/lib/nginx/modules \\ --conf-path = /etc/nginx/nginx.conf \\ --error-log-path = /var/log/nginx/error.log \\ --http-log-path = /var/log/nginx/access.log \\ --pid-path = /run/nginx.pid \\ --lock-path = /var/lock/nginx.lock \\ --user = www-data \\ --group = www-data \\ --http-client-body-temp-path = /var/lib/nginx/body \\ --http-fastcgi-temp-path = /var/lib/nginx/fastcgi \\ --http-proxy-temp-path = /var/lib/nginx/proxy \\ --http-scgi-temp-path = /var/lib/nginx/scgi \\ --http-uwsgi-temp-path = /var/lib/nginx/uwsgi \\ --with-openssl = ../openssl-1.1.0g \\ --with-openssl-opt = enable-ec_nistp_64_gcc_128 \\ --with-openssl-opt = no-nextprotoneg \\ --with-openssl-opt = no-weak-ssl-ciphers \\ --with-openssl-opt = no-ssl3 \\ --with-pcre = ../pcre-8.41 \\ --with-pcre-jit \\ --with-zlib = ../zlib-1.2.11 \\ --with-compat \\ --with-file-aio \\ --with-threads \\ --with-http_addition_module \\ --with-http_auth_request_module \\ --with-http_dav_module \\ --with-http_flv_module \\ --with-http_gunzip_module \\ --with-http_gzip_static_module \\ --with-http_mp4_module \\ --with-http_random_index_module \\ --with-http_realip_module \\ --with-http_slice_module \\ --with-http_ssl_module \\ --with-http_sub_module \\ --with-http_stub_status_module \\ --with-http_v2_module \\ --with-http_secure_link_module \\ --with-mail \\ --with-mail_ssl_module \\ --with-stream \\ --with-stream_realip_module \\ --with-stream_ssl_module \\ --with-stream_ssl_preread_module \\ --with-debug \\ --with-cc-opt = '-g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -Wdate-time -D_FORTIFY_SOURCE=2' \\ --with-ld-opt = '-Wl,-Bsymbolic-functions -fPIE -pie -Wl,-z,relro -Wl,-z,now' $ make #这个操作需要花费十分钟左右 $ sudo make install $ sudo systemctl start nginx.service && sudo systemctl enable nginx.service 遇到的问题 nginx: [emerg] mkdir() \"/var/lib/nginx/body\" failed Just create directory $ sudo mkdir -p /var/lib/nginx && sudo nginx -t $ sudo nano /lib/systemd/system/nginx.service 输入如下内容 # Stop dance for nginx # ======================= # # ExecStop sends SIGSTOP (graceful stop) to the nginx process. # If, after 5s (--retry QUIT/5) nginx is still running, systemd takes control # and sends SIGTERM (fast shutdown) to the main process. # After another 5s (TimeoutStopSec=5), and if nginx is alive, systemd sends # SIGKILL to all the remaining processes in the process group (KillMode=mixed). # # nginx signals reference doc: # http://nginx.org/en/docs/control.html # [Unit] Description=A high performance web server and a reverse proxy server Documentation=man:nginx(8) After=network.target [Service] Type=forking PIDFile=/run/nginx.pid ExecStartPre=/usr/sbin/nginx -t -q -g 'daemon on; master_process on;' ExecStart=/usr/sbin/nginx -g 'daemon on; master_process on;' ExecReload=/usr/sbin/nginx -g 'daemon on; master_process on;' -s reload ExecStop=-/sbin/start-stop-daemon --quiet --stop --retry QUIT/5 --pidfile /run/nginx.pid TimeoutStopSec=5 KillMode=mixed [Install] WantedBy=multi-user.target 重启nginx服务 sudo systemctl start nginx.service && sudo systemctl enable nginx.service check nginx service is up $ sudo systemctl status nginx.service $ ps aux | grep nginx $ curl -I 127 .0.0.1 重启nginx出现 Directory index of \"/www/pingbook.top/pingbook.top/output/\" is forbidden, 解决方法是在location里面设置index index.html,如下: location / { # 使用alias时，目录名后面一定要加\"/\" alias /www/pingbook.top/pingbook.top/output/; index index.html; try_files $uri $uri/ index.html last; } Https 加密你的网站 参考文档: https://certbot.eff.org/lets-encrypt/debianother-nginx $ sudo wget https://dl.eff.org/certbot-auto $ sudo chmod a+x certbot-auto $ # 获取证书 $ sudo ./certbot-auto certonly --standalone --email alterhu2020@gmail.com -d pingbook.top -d www.pingbook.top 报错如下,很多的依赖没有安装成功: dpkg: error processing package python-zope.component ( --configure ) : dependency problems - leaving unconfigured Setting up libaugeas0 ( 1 .8.0-1+deb9u1 ) ... dpkg: dependency problems prevent configuration of python-mock: python-mock depends on python-funcsigs ( > = 1 ) ; however: Package python-funcsigs is not configured yet. python-mock depends on python-pbr ( > = 1 .3 ) ; however: Package python-pbr is not configured yet. python-mock depends on python-six ( > = 1 .9 ) ; however: Package python-six is not configured yet. dpkg: error processing package python-mock ( --configure ) : dependency problems - leaving unconfigured dpkg: dependency problems prevent configuration of python-requests: python-requests depends on python-urllib3 ( > = 1 .19.1 ) ; however: Package python-urllib3 is not configured yet. python-requests depends on python-chardet ; however: Package python-chardet is not configured yet. python-requests depends on python-urllib3 ( << 1.1 9 .2 ) ; however: Package python-urllib3 is not configured yet. dpkg: error processing package python-requests ( --configure ) : dependency problems - leaving unconfigured dpkg: dependency problems prevent configuration of certbot: certbot depends on python-certbot (= 0 .10.2-1 ) ; however: Package python-certbot is not configured yet. dpkg: error processing package certbot ( --configure ) : dependency problems - leaving unconfigured Processing triggers for libc-bin ( 2 .24-11+deb9u3 ) ... Errors were encountered while processing: python-dnspython python-idna python-parsedatetime python-pyasn1 python-tz python-pkg-resources python-configargparse python-six python-zope.interface python-psutil python-pbr python-enum34 python-cryptography python-virtualenv python-funcsigs python-zope.hookable python-ipaddress python-pyicu python-zope.event python-rfc3339 python-setuptools python-urllib3 python-configobj python-chardet python-acme python-openssl python-certbot python-zope.component python-mock python-requests certbot Sub-process /usr/bin/dpkg returned an error code (1) $ cd /var/cache/apt/ $ cd archives/ $ sudo rm -rf * 所以我想起以前用的一个网友的脚本,不用安装一堆繁杂的包,地址: https://github.com/xdtianyu/scripts/blob/master/lets-encrypt/ README - CN .md \" 1. 在nginx的配置文件里面配置location: \"` # https 配置Let's Encrypt location &#94;~ /.well-known/acme-challenge/ { allow all; default_type \"text/plain\"; root /www; } $ sudo wget https://raw.githubusercontent.com/xdtianyu/scripts/master/lets-encrypt/letsencrypt.conf $ sudo wget https://raw.githubusercontent.com/xdtianyu/scripts/master/lets-encrypt/letsencrypt.sh $ sudo chmod +x letsencrypt.sh $ sudo nano letsencrypt.conf $ sudo ./letsencrypt.sh letsencrypt.conf ### 删除已经安装的nginx sudo apt update && sudo apt upgrade -y # update all package index sudo apt-get purge nginx nginx-common # Removes everything. nginx 采用的C语言编写的,需要对应的C编译器( GCC ): sudo apt install build-essential -y \" `","tags":"树莓派","url":"articles/pi-nginx/"},{"title":"[环境搭建] Debian如何安装配置Tomcat9","text":"安装 参考文档: https://www.howtoforge.com/tutorial/ubuntu-apache-tomcat/ 推荐: https://gist.github.com/jniltinho/a7bd30288342a5d352e6#file-install_tomcat-sh-L33 安装JDK和配置环境变量(采用下面的配置环境变量/etc/profile), 注意截止到20180709, oracle没有提供debain的32位系统安装tar包,所以这里使用的是32位的jdk1.8 $ nano ~/.bashrc export JAVA_HOME = /usr/lib/jvm/jdk-8-oracle-arm32-vfp-hflt export PATH = $JAVA_HOME /bin: $PATH $ source ~/.bashrc $ echo $JAVA_HOME 添加组和用户 $ sudo groupadd tomcat $ sudo useradd -s /bin/false -g tomcat -d /opt/tomcat tomcat 下载tomcat9 $ tar zxvf jdk1.8.0_171.tar.gz $ sudo nano /etc/profile JAVA_HOME = /home/pi/jdk1.8.0_171 CLASSPATH = $JAVA_HOME /lib/ PATH = $PATH : $JAVA_HOME /bin export PATH JAVA_HOME CLASSPATH $ source /etc/profile $ java 可能下载的是64位的jdk,但是系统只能运行32位的jdk /bin/javac: cannot execute binary file: Exec format error $ cd /home/pi $ sudo wget http://apache.cs.utah.edu/tomcat/tomcat-9/v9.0.10/bin/apache-tomcat-9.0.10.tar.gz $ tar zxvf apache-tomcat-9.0.10.tar.gz $ cd /home/pi/apache-tomcat-9.0.10/ $ sudo groupadd tomcat $ sudo useradd -M -s /bin/nologin -g tomcat -d /home/pi/apache-tomcat-9.0.10 tomcat $ sudo chgrp -R tomcat conf $ sudo chmod g+rwx conf $ sudo chmod g+r conf/* $ sudo chown -R tomcat webapps/ work/ temp/ logs/ $ sudo chown -R tomcat:tomcat * $ sudo chown -R tomcat:tomcat /home/pi/apache-tomcat-9.0.10 $ sudo chmod -R 757 conf/ $ sudo chmod -R 757 logs/ $ sudo chmod -R 757 webapps/ 配置 tomcat开机启动 $ sudo nano /etc/systemd/system/tomcat.service # Systemd unit file for tomcat [ Unit ] Description = Apache Tomcat Web Application Container After = syslog.target network.target [ Service ] Type = forking Environment = JAVA_HOME = /home/pi/jdk1.8.0_171 Environment = CATALINA_PID = /home/pi/apache-tomcat-9.0.10/temp/tomcat.pid Environment = CATALINA_HOME = /home/pi/apache-tomcat-9.0.10 Environment = CATALINA_BASE = /home/pi/apache-tomcat-9.0.10 Environment = 'CATALINA_OPTS=-Xms512M -Xmx824M -server -XX:+UseParallelGC' Environment = 'JAVA_OPTS=-Djava.awt.headless=true -Djava.security.egd=file:/dev/./urandom' ExecStart = /home/pi/apache-tomcat-9.0.10/bin/startup.sh ExecStop = /bin/kill -15 $MAINPID User = tomcat Group = tomcat [ Install ] WantedBy = multi-user.target $ sudo systemctl daemon-reload $ sudo systemctl start tomcat $ sudo systemctl enable tomcat Configure Apache Tomcat User $ cd /home/pi/apache-tomcat-9.0.10/conf/ $ sudo nano tomcat-users.xml <role rolename = \"manager-gui\" /> <user username = \"admin\" password = \"admin\" roles = \"manager-gui,admin-gui\" /> $ cd webapps/manager/META-INF/ $ sudo nano context.xml comment: <!-- <Valve className = \"org.apache.catalina.valves.RemoteAddrValve\" allow = \"127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1\" /> --> $cd webapps/host-manager/META-INF/ #sudo nano context.xml comment: <!-- <Valve className = \"org.apache.catalina.valves.RemoteAddrValve\" allow = \"127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1\" /> --> $ sudo systemctl restart tomcat.service","tags":"树莓派","url":"articles/pi-tomcat/"},{"title":"[环境搭建]  svn 安装配置","text":"SVN 安装 执行如下命令进行安装: $ sudo apt-get -y install subversion 启动 svn 服务: d代表的是daemon 进程 $ svnserve -d $ ps aux | grep svnserve 若出现如下内容： wkr 6537 0.0 0.0 13784 956 ? Ss 16:18 0:00 svnserve -d wkr 7593 0.0 0.0 5784 864 pts/0 S+ 21:57 0:00 grep –color=auto svnserve 表示服务已开启。（注意：一定要有第1行，只有第2行说明服务未启动） 关闭 svn 服务: $ killall svnserve 重启 svn 服务: $ svnserve -d -r /srv 新建一个仓库: $ sudo adduser --system --home /srv/svn --disabled-password --disabled-login --group svn $ sudo svnadmin create /srv/svn $ sudo chown -R svn:svn /srv/svn change user, change group 改变文件对应的用户和用户组 修改仓库配置文件 编辑配置文件: svnserve.conf $ sudo nano /srv/svn/conf/svnserve.conf [ general ] anon-access = none auth-access = write authz-db = authz 修改帐户文件 nano /srv/svn/conf/passwd 和 sudo nano /srv/svn/conf/authz , 此处忽略. 配置svn开机自动启动 新建一个svnserve配置文件在 /et/default/svnserve 文件,内容如下: # svnserve options DAEMON_ARGS=\"--daemon --pid-file /run/svnserve/svnserve.pid --root /srv/svn --log-file /var/log/svn/svnserve.log\" 注意 新建log文件,这些是 /etc/default/svnserve 中的文件的配置涉及的几个文件,如果执行 sudo systemctl restart svnserve.service 失败,会自动删除文件夹 /run/svnserve $ sudo mkdir /run/svnserve $ sudo chown -R svn:svn /run/svnserve/ $ sudo chmod -R 777 /run/svnserve/ $ sudo mkdir /var/log/svn $ sudo chown -R svn:svn /var/log/svn/ $ sudo chmod -R 777 /var/log/svn/ 新建service启动服务文件 $ sudo nano /etc/systemd/system/svnserve.service [ Unit ] Description = Subversion protocol daemon After = syslog.target network.target [ Service ] Type = forking RuntimeDirectory = svnserve PIDFile = /run/svnserve/svnserve.pid EnvironmentFile = /etc/default/svnserve ExecStart = /usr/bin/svnserve $DAEMON_ARGS User = svn Group = svn KillMode = control-group Restart = on-failure [ Install ] WantedBy = multi-user.target 重启机器后出现这个错误:(原因是上面的第一个操作我没有做,就是没有创建一个文件 /etc/default/svnserve ,或者其中涉及到的文件 /var/log/svn , /run/svnserve 没有新建,或者没有配置可写权限对于用户 svn ) pi @ pingbook :~$ systemctl status svnserve . service ● svnserve . service - Subversion protocol daemon Loaded : loaded (/ etc / systemd / system / svnserve . service ; enabled ; vendor preset : enabled ) Active : failed ( Result : resources ) since Sun 2018-07-08 20 : 06 : 56 CST ; 28s ago 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : Failed to start Subversion protocol daemon . 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : svnserve . service : Unit entered failed state . 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : svnserve . service : Failed with result 'resources' . 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : svnserve . service : Service hold-off time over , scheduling restart . 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : Stopped Subversion protocol daemon . 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : svnserve . service : Start request repeated too quickly . 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : Failed to start Subversion protocol daemon . 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : svnserve . service : Unit entered failed state . 7月 08 20 : 06 : 56 pingbook systemd [ 1 ] : svnserve . service : Failed with result 'resources' . checkout一份代码到nginx服务器,保持web同步,注意checkout的目录用户要是svn的用户和组,这样hook才能有权限读写 $ sudo svn co svn://localhost/svn /www/pingbook.top --username \"hr\" $ cd /www/pingbook.top $ sudo chown -R svn:svn * $ sudo chown -R svn:svn /www/pingbook.top $ sudo chmod -R 757 /www/pingbook.top $ sudo chmod -R 757 /www/pingbook.top/.svn # 配置svn数据仓库 $ sudo svn cleanup 如果commit的时候发现 hook 的 post-commit 总是报错: post-commit hook failed (exit code 255) with no output ,需要检查对应的文件的读写权限. 1. 检查对应的 post-commit 的用户组是 svn ,对应的文件有执行权限: sudo chmod g+e /srv/svn/hook/post-commit","tags":"树莓派","url":"articles/pi-svn/"},{"title":"[环境搭建] 配置采用NAT123进行树莓派部署","text":"安装步骤 2018-07-09 更新,下面的方法如果安装失败,尝试官方的安装指南: http://www.mono-project.com/download/stable/#download-lin-raspbian 1. 下载对应的linux版本的nat123安装包: http://www.nat123.com/Pages_2_32.jsp 2. 解压缩到一个目录里面: tar zxvf nat123linux20180627.tar.gz ~~3. 安装 sudo apt-get install -y mono-complete ,如果安装失败,请参见另外的一篇文章设置对应的国内镜像: https://pingbook.top/articles/pi-mirrors/ ~~ 4. 上面的 momo-complete 的安装需要一段时间,大约十分钟左右.~~ $ mono /home/pi/nat123/nat123linux.sh service & 采用如下方式进行安装 mono-complete 参考地址: http://www.mono-project.com/download/stable/#download-lin-raspbian $ sudo apt install apt-transport-https dirmngr $ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF $ echo \"deb https://download.mono-project.com/repo/debian stable-raspbianstretch main\" | sudo tee /etc/apt/sources.list.d/mono-official-stable.list $ sudo apt update $ sudo apt install mono-complete","tags":"树莓派","url":"articles/pi-nat123/"},{"title":"[树莓派] 树莓派3B安装","text":"树莓派安装 因为感觉空间越来越小了,不能使用现在的需要了,所以决定重新安装系统. 安装完成后，TF卡被分成两个分区： 67MB vfat格式的引导分区（系统启动后被挂载在/boot目录） TF卡剩余空间 ext4格式的磁盘分区 由于Windows下不识别ext4格式的磁盘，在资源管理器中查看TF卡只显示一个67MB大小、名字为boot的盘符。 若想恢复TF卡整个空间为windows可识别的fat32/exfat格式，需要使用低级格式化工具HDD Low Level Format Tool（windows磁盘管理器无法处理ext4格式磁盘）。 安装版本为lite版本 在没有显示屏网线的情况下可以通过如下方式进行远程操作. 1. 下载镜像 2. 新建一个空文件没有后缀名: ssh, 然后放到 /boot 文件夹里面. 这两个文件在启动的时候会自动复制到指定的目录里面. 3. 新建一个文件 wpa_supplicant.conf ,输入以下的内容,按照你的环境进行配置对应的wifi名称和密码: ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=CN network={ ssid=\"MiniWifi\" psk=\"L0ngh)171130AVb\" key_mgmt=WPA-PSK } network={ ssid=\"GDS-GUEST\" psk=\"Gr33nD0t!\" } 安装完成后,需要登录到电脑,这个电脑和你的树莓派需要在一个局域网里面. 有很多人统建使用 advanced ip scanner 这个工具, 我也使用了一段时间,开始还好,后面发现有时候扫描不到你的树莓派. 在网上搜索了一阵发现还有同款的一个扫描类的软件 angry ip scanner 之所以选择他是因为他对不同的局域网环境都能正确的扫描到树莓派对应的机器名称和机器ip address. 远程桌面工具,不是VNC 直接运行如下命令安装对应的远程桌面工具: $ sudo apt install -y xrdp","tags":"树莓派","url":"articles/pi-installation/"},{"title":"[Pelican高级] pelican 博客高级配置","text":"前言 继续上一篇的基本配置后,这里我将记录下涉及到的一些高级pelican的使用方法,也是自己摸索的一些网上的经验,还有一些自己自定义的功能. 关键字 Google adsense 百度站长 Google Console Tipue Search fabfile 不蒜子,浏览量统计 添加google和百度的SEO (2018-07-09) 谷歌的收录比较简单,直接登录到这里: https://www.google.com/webmasters ,按照提示添加自己 的网站即可,添加对应的sitemap,robots.txt即可. 百度的可以通过进入百度站长 http://zhanzhang.baidu.com ,方法同上面的谷歌添加网站,验证即可. 为了网站的长期可持续发展,添加一些广告也是没办法的: https://www.google.com/adsense/new/u/0/pub-1893384651266286/home 增加搜索功能(2018-07-09) 使用的插件是: Tipue_Search 自动化部署 看了一下官方的自动化部署相关的文章 fabric/Make , 提到在linux下 你可以很方便的使用 make 命令来操作相关的自动化,它对应的是 makefile ,你在使用 pelican-quickstart 命令的时候会提示你是否需要生成 这个文件. 执行命令 pelican-quickstart 的时候也会生成一个文件 fabfile.py ,这个文件同 makefile 是一样的,只不过一个是用python实现的,一个是基于linux shell 实现的. 在window下打开这个文件,发现里面的文件报了好多错,定位到 from fabric.api import * ,类似 no module found env,local 由于对 fabfile 不太熟悉,到网上找了一圈解决方法,发现缺少对应的包导致报错命令无法执行. 执行下面的命令完成对应的安装操作. pip install pycryptodome pip install Fabric3 # 注意这里是Fabric3,不要使用fabric 百度站长不能收录 按照官网提示,下载了对应的html文件到pelican的目录下面使用附件的形式复制到对应的output目录下面,推荐不要使用 cname 的方式. 例如我下载的html文件是: baidu_verify_TVrRxDNlTJ.html ,完整的配置在 pelican.conf 文件中,如下: STATIC_PATHS = ['static', 'extra/README.md', 'extra/robots.txt', 'extra/CNAME', 'extra/favicon.ico', 'extra/baidu_verify_TVrRxDNlTJ.html', 'extra/google9db45b3da980c919.html'] EXTRA_PATH_METADATA = { 'extra/README.md': {'path': 'README.md'}, 'extra/robots.txt': {'path': 'robots.txt'}, 'extra/CNAME': {'path': 'CNAME'}, 'extra/favicon.ico': {'path': 'favicon.ico'}, 'extra/baidu_verify_TVrRxDNlTJ.html': {'path': 'baidu_verify_TVrRxDNlTJ.html'}, 'extra/google9db45b3da980c919.html': {'path': 'google9db45b3da980c919.html'} } 加入浏览量统计 在谷歌上溜达了一圈,找到了一个博客: http://xiaohanyu.me/about/,随便看了一下作者的博客,看到了他去面试的谷歌和Facebook的面试经历, 感觉挺好玩的,里面提到了他们代码面试的工具: https://coderpad.io . 去玩了一下,感觉挺好玩. 好吧,扯远了….. 言归正文,推荐一个好用简单的统计页面浏览量和网站浏览量的插件. * 工具 不蒜子 ,代码也是只需要简简单单的几号就可以了,把这四行代码放到页面中你想要放的地址: <script async src= \"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\" ></script> <span id= \"busuanzi_container_site_pv\" > 总访问量 <span id= \"busuanzi_value_site_pv\" ></span> 次 </span> , <span id= \"busuanzi_container_site_uv\" > 总访客 <span id= \"busuanzi_value_site_uv\" ></span> 人 </span> <span id= \"busuanzi_container_page_pv\" > , 浏览量: <span id= \"busuanzi_value_page_pv\" ></span></span>","tags":"博客搭建","url":"articles/pelican-advance/"},{"title":"[Pelican初级] pelican 博客搭建","text":"我真是太折腾了,也没能坚持下去,去年陆陆续续用 hexo 写了一段时间的博客,最终没能坚持下去! 这个博客建立算是建立起来了, 我会认真的去写博客,坚持到最后! 关键字 pelican markdown github 搭建步骤 最好的方式莫过于官方文档: 官方入坑道路 . 下面的步骤都是很简单,网上一堆教程,我这里就不多说了,记下这些步骤 // 如果需要使用markdown这个高逼格的语法去写博客,请安装一下的包 # pip install pelican markdown typogrify # mkdir pingbook.top # cd pingbook.top # pelican-quickstart 安装上面的步骤操作下来后,弹出如下的提示让你配置,这些配置都可以以后在 pelicanconf.py 修改,直接默认回车一路下去就好了! pelican-quickstart执行命令后，会提示输入博客的配置项，除了少数几个必填以外，其它都可以选择默认，而且都可以在pelicanconf.py文件中进行更改，所以你可以随意选择。 1. Where do you want to create your new web site?[.] (你想在哪里创建你的网站，默认为当前目录) 2. What will be the title of this web site?(网站的标题是什么) 3. Who will be the author of this web site?(网站的作者是谁) 4. What will be the default language of this web site? [en] (网站的默认语言是),这里我们写'zh'中文 5. Do you want to specify a URL prefix? e.g., http://example.com(Y/n) (是否指定域名),Y 6. What is your URL prefix?(see above example; no trailing slash)(输入域名，不能包含反斜杠'/'),http://moelove.info 7. Do you want to enable article pagination?(是否启用文章分页) 8. Do you want to generate a Makefile to easily manage your website?(是否生成一个Makefile来管理网站(这里我建议生成，因为会比较方便的)) 9. Do you want an auto-reload & simpleHTTP script to assist with theme and site development?(是否想有一个自动加载的小型http脚本用来修改主题和站点开发) 10. Do you want to upload your website using FTP? 11. Do you want to upload your website using SSH? 12. Do you want to upload your website using Dropbox? 13. Do you want to upload your website using S3? 命令使用 由于本人使用的是windows,这里我使用了两个命令: # pelican content # 根据content中的内容，生成静态网站到output目下 # cd output && python -m pelican.server # cd output && python -m SimpleHTTPServer 主题和插件安装 theme安装 下载主题文件,添加配置: THEME = './pelican-themes/gum' 插件安装 下载插件文件,添加如下配置: PLUGIN_PATHS = [u\"pelican-plugins\"] PLUGINS = [u\"sitemap\",u\"gzip_cache\",u\"neighbors\",u\"related_posts\"] SITEMAP = { 'format': 'xml', 'priorities': { 'articles': 0.7, 'indexes': 0.5, 'pages': 0.3 }, 'changefreqs': { 'articles': 'weekly', 'indexes': 'daily', 'pages': 'monthly' } } 字体更改 1.下载字体文件,到网站的静态文件夹内,具体可以参考让wordpress主题绕开对google的依赖.不过此种方法也有些问题.把静态资源放到Github上加载时间也没别之前好多少. 2.把Google的静态公共库替换为国内的公共库.例如我的给替换成360的镜像地址.其实这种方法也有些弊端,例如国外用户访问就会出现加载过慢的问题.但是毕竟我们在'朝内',所以就换成360的资源库吧.操作如下 在对应的主题的css文件中修改对应的google font切换到国内的镜像.例如本周使用的是gum主题,转到对应的css文件 gumby.css ,修改如下: #static/css/目录下css文件中,例如gumby.css @import url ( // fonts . googleapi . com / css ? family = Overlock : 400 , 700 , 900 ); @import url ( // fonts . googleapi . com / css ? family = PT + Mono ); #替换为 @import url ( // fonts . useso . com / css ? family = Overlock : 400 , 700 , 900 ); @import url ( // fonts . useso . com / css ? family = PT + Mono ); 国内其他开公共库: 百度CDN公共库; 新浪云计算CDN公共库; 又拍云JS库CDN服务; 七牛云静态文件CDN; 高级语法 静态图片 新建一个目录在 content 下面,例如 images ,然后在 pelicanconf.py 设置如下: STATIC_PATHS = ['images','downloads'] ,在对应的md中可以这样写语法对应图片: ![测试图片显示]({attach}/static/images/test.png) 部署 部署到github上 新建一个仓库repository,仓库名称和你的github昵称相同,例如你的名称是abc,那么创建的仓库名称是: abc.github.io 也可以创建一个组织organization,在组织下面在创建一个仓库repository,仓库名称和你的组织也可以创建一个组织organization名称相同, 例如你的organization名称是abc,那么创建的仓库名称是: abc.github.io 完成以上的操作后上传对应的源码到github上,这里省略,命令如下: cd output git init git add . git remote add origin 仓库git地址 git push -u origin master","tags":"博客搭建","url":"articles/try-pelican/"},{"title":"[面试] 4. 白盒测试需要关注的知识点","text":"参考博客: https://www.cnblogs.com/molrang/p/6420918.html 自动化测试 考虑的因素 ①、项目的影响（能否帮助项目进度、覆盖率、风险） ②、复杂度（是否容易实现，包括数据和其他环境等） ③、时间（实现自动化需要多少时间） ④、早期需求和代码的稳定性（需求或代码能否证明是在范围内变化的） ⑤、维护工作量（代码能否能长期保持相对稳定） ⑥、覆盖率（自动化测试能否覆盖程序的关键特性和功能） ⑦、资源（是否拥有足够的人力、硬件和数据资源来运行自动化测试） ⑧、执行（负责执行的人员是否有足够的技能和时间去运行） ⑨、自动化测试管理 白盒测试 按照程序内部结构，逻辑驱动测试程序,目的是检测产品内部动作是否按照设计说明书的规范进行，检验程序的每条路径是否都能按照预定要求进行工作 白盒测试方法 ①、静态测试 静态测试是指不运行程序本身，仅通过分析程序文档结构，软件执行过程，检测程序的正确性，主要有变量，接口，递归等。 ②、动态测试 动态方法是指运行程序，检查运行结果与预期结果对比差异，并分析抗压性，健壮性等，这种测试包括三部分：构造测试实例，执行程序，分析程序输出结果。 区别一：静态测试是用于预防的，动态测试是用于矫正的 区别二：多次的静态测试比动态测试要效率和效益高 区别三：静态测试综合测试程序代码 区别四：在相当短的时间里，静态测试的覆盖度能达到100%，而动态测试经常是只能达到50%左右，原因动态测试发现的bug大部分只是在测试实际执行的那部分代码 区别五：动态测试比静态测试更花时间 区别六：静态测试比动态测试更能发现 bug 区别七：静态测试的执行可以在程序编码编译前，动态测试只能在编译后才能执行 区别八：静态测试能发现动态测试所不能发现的一些:\"Syntax error,code that hard to maintain,code that hard to test,code that does not confirm to coding standard, and ANSI violations\" 白盒测试方法 ①、尽量先用自动化工具来进行静态解析 ②、建议先从静态测试开始（静态结构分析、代码走查、静态质量度量），然后进行动态测试（如覆盖率测试） ③、以静态分析结果作为依据，再使用代码检查和动态测试方法对静态分析结果进行进一步确认，提高测试效率及准确性 ④、覆盖率测试是白盒测试的重要手段，在测试报告中可作为量化指标的依据，对于软件的重点模块，应使用多种覆盖率标准衡量代码的覆盖率 包括的有代码检查,SQL语句的测试,","tags":"面试","url":"articles/4-software-testing-white/"},{"title":"[面试] 3. 黑盒测试需要注意的几个关注点","text":"基本理论概念 是软件工程中的一个非常重要的环节，是开发项目整体的一部分。 是有计划有组织的，是伴随软件工程的诞生而诞生的，软件测试不是万能的， 不可能发现全部缺陷，软件测试是有局限性的。 测试的目的 1）验证软件是否满足 软件开发合同 或者项目开发计划，系统/子系统设计文档，软件需求规格说明，软件产品说明等规定的软件质量要求 2）通过测试，发现软件缺陷 3）为软件产品的质量测量和评价提供依据 测试用例的设计规则 基于测试需求的原则 基于测试方法的原则 兼顾 测试充分性 和 效率的原则 测试用例的方法有: a. 等价类: 是在 分析 需求规格说明 基础上，把程序的输入域 划分成 若干个部分，然后再每部分中选取 代表性数据 形成测试用例. * 步骤： a)划分有效等价类，对规格说明 是 有意义 合理的 输入数据 所构成的集合 b)划分无效等价类，对 规格说明 是 无意义 不合理的 输入数据 所构成的集合 c) 为每一个等价类 定义一个唯一的编号 d）为每一个等价类 设计一组测试用例 确保 覆盖相应的等价类 b.边界值分析: 边界值分析法 是针对 边界值 进行测试的 使用 等于 大于 或者小于边界值的数据对程序进行测试的方法 就是边界值分析法。 * 步骤： a）通过分析 规格说明 找出 所有 可能的 边界条件 b) 对每一个边界条件 给出 满足 和 不满足的输入数据 c) 设计相应的 测试用例 c. 错误推测法: 基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。 d. 因果图法 等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。 如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。 e. 判定表驱动法 判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。 f. 正交实验法 * 步骤 1 提取功能说明,构造因子–状态表 把影响实验指标的条件称为因子.而影响实验因子的条件叫因子的状态.利用正交实验设计方法来设计测试用例时,首先要根据被测试软件的规格说明书找出影响其功能实现的操作对象和外部因素,把他们当作因子,而把各个因子的取值当作状态.对软件需求规格说明中的功能要求进行划分,把整体的概要性的功能要求进行层层分解与展开,分解成具体的有相对独立性的基本的功能要求.这样就可以把被测试软件中所有的因子都确定下来,并为确定个因子的权值提供参考的依据.确定因子与状态是设计测试用例的关键.因此要求尽可能全面的正确的确定取值,以确保测试用例的设计作到完整与有效。 2 加权筛选,生成因素分析表 对因子与状态的选择可按其重要程度分别加权.可根据各个因子及状态的作用大小,出现频率的大小以及测试的需要,确定权值的大小。 3 利用正交表构造测试数据集 正交表的推导依据Galois理论（这里省略,需要时可查数理统计方面的教材） 1. Dr. Genichi Taguchi 设计的正交表: https://www.york.ac.uk/depts/maths/tables/orthogonal.htm 2. Technical Support ( support.sas.com ) com 提供的 http://support.sas.com/techsup/technote/ts723_Designs.txt 利用正交实验设计方法设计测试用例,比使用等价类划分,边界值分析,因果图等方法有以下优点:节省测试工作工时；可控制生成的测试用例数量；测试用例具有一定的覆盖率。 g. 场景图法 现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。 这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。 软件的内部质量 功能性：当软件在指定条件下使用时，软件产品 提供 满足 明确的和隐含的能力，包括适合性，准确性，互操作性，安全保密性，依从性 可靠性：在指定条件下使用时 软件产品维持规定的性能级别的能力；包括，成熟性，容错性，易恢复性，依从性 易用性：在指定条件下使用 软件产品被理解被学习 使用和 吸引用户的能力 包括 易学性 易操作性 吸引性 依从性 效率性：在规定条件下 软件产品执行其功能时使用合适数量和类别资源的能力；包括 资源利用性 和效率依从性 、 维护性：软件产品 可以被修改的能力可能包括 纠正 改进 软件对环境 需求 和功能规格说明变化的适应 包括，易分析性，易改变性，稳定性，易测试性，依从性 可移植性：软件产品 从一种环境迁移到另外一种环境的能力，包括，适应性，易安装性，共存性，易替换性，可移植性的依从性。 兼容性: 什么是兼容性测试?兼容性测试侧重哪些方面? 主要检验的是软件的可移植性，检查软件在不同的硬件平台软件平台上是否可以正常的运行。细分会有：平台的兼容，网络兼容，数据库兼容，数据格式的兼容等。 测试的生命周期 单元测试，集成测试，确认测试(Certify Testing)，系统测试，验收测试, 回归测试(Regression Testing). 单元测试: 软件设计文档 集成测试：软件结构设计文档 配置项测试：需求规格说明书（接口需求规格说明） 系统测试：用户需求（研制合同或系统需求） 验收测试：软件研制合同（用户需求或系统需求） 测试方法 黑盒测试，白盒测试, 静态测试和动态测试，手工测试和动态测试，回归测试，公测 * 白盒 逻辑测试或者基于程序的测试，这种测试 应了解软件程序的内部构造，并且根据内部构造 来设计测试用例。发生在单元测试,集成测试或确认测试. 黑盒测试是功能性测试，一般采用穷举输入测试. * 黑盒 又称功能测试，数据驱动测试，或者基于规格说明的测试，这种测试不必要了解 对象的内部逻辑结构，而是根据需求说明书中的功能来设计测试用例. 白盒测试是结构测试，一般是穷举路径测试，检测内部逻辑驱动结构 * 灰盒 持续的集成测试 冒烟测试 一段时间内 针对某个模块【刚新增的模块 或者刚刚修改完的模块】开展某个专项测试（功能测试）， 回归测试 长时间，针对某个指定的版本【刚新增的模块 以及与他相关的其他模块，进行专项的测试活动】 功能测试 1． 测试需求：测试的规格说明书，主要作用是定义待测试的模块 和 功能模块的测试要点 2． 测试计划：测试过程中的纲领性文件，对测试活动中的测试环境，测试方法，测试时间人员安排。 3． 测试用例：是测试需求的细化，是一群元素的集合，主要包含，用例编号，操作步骤/测试数据，预期结果，实际结果，判定，覆盖需求。 4． 缺陷报告：将软件的实际情况 和 测试用例的预期结果相比较，记录问题报告单。 5． 测试的基本过程：四个过程，测试策划，测试设计，测试执行，测试总结 6． 测试所需要的文档：测试需求，测试计划，测试用例，缺陷报告，测试报告（可能编写） 可能的面试题目 Beta测试与Alpha测试有什么区别? Beta是用户实际使用的测试，没有开发者在场，Alpha测试是公司内部测试，有开发者监控。 什么是桩模块？什么是驱动模块？ 集成测试前要为被测模块编辑一些模拟其下级功能的子模块的替身，以代替被测模块的借口，接受或者传递数据，这些假模块被称为桩模块。 驱动模块一般为主程序，它接收测试数据并将这些数据传递到被测试模块。 什么是扇入和扇出？ 扇入是指该模块被调用的次数，扇入大，说明该模块的复用性好。 扇出是指该模块调用其他模块的个数，扇出大，说明该模块的业务逻辑复杂。 你认为做好测试工作的的关键是什么？ 目的，管理，规范。 简述一下缺陷的生命周期? 提交->确认->分配->修复->验证->关闭 软件的安全性应该从哪几个方面去测试？ 1，用户认证机制， 2，加密机制 3，安全防护策略，安全日志等， 4，数据备份和恢复 5，防病毒系统。 单元测试，集成测试，系统测试的区别？ 测试方法不同：单元测试属于白盒测试，集成测试属于灰盒测试，系统测试属于黑盒测试。 考察范围测试重点不同：单元测试注重单元内部的数据结构，逻辑控制，异常处理。 集成测试注重模块之间的接口及接口之间的数据传递，系统测试注重满足需求。 基准不同：单元测试主要的逻辑覆盖，集成测试主要是接口覆盖，系统测试是测试用例对需求规格的覆盖率。","tags":"面试","url":"articles/3-software-testing-black/"}]}