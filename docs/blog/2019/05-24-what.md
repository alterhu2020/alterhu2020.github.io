---
title: 5月24日整理
---


## `extends QuartzJobBean` 和 `implements Job `  difference

在spring-boot-quartz中使用提供的接口创建job的时候有两种方式：

- 实现接口`Job` 

如果采用的是implements job接口的形式创建job，name我们如何获取任务传递过来的外部参数呢？

```java
 @Override
    public void execute(JobExecutionContext context) {
        try {
            // 通过访问 JobExecutionContext 获取JobDataMap 对象，从而访问对应的参数
            JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();
            Object jobName = jobDataMap.get("name");
        }
    }

```
有没有一种更方便的形式进行访问获取`JobDataMap`中的参数和值呢？是的，这个就是`QuartzJobBean`类做得

- 继承抽象类`QuartzJobBean`

官方的说明是： 更优雅采用java对象思想来访问传过来的参数。

```java
public class MyJob extends QuartzJobBean {
    private String parameter1;


    public void setParameter1(String parameter1) {
        this.parameter1 = parameter1;
    }

    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        System.out.println("My job is running with "+parameter1);
    }
}
```

## @DisallowConcurrentExecution 配置quartz并发执行

> 可能有多个触发器使用该job，所以避免并发执行这个任务

@DisallowConcurrentExecution
@PersistJobDataAfterExecution



## 常用基本quartz cron表达式

```xml
            每隔5秒执行一次：*/5 * * * * ?

             每隔1分钟执行一次：0 */1 * * * ?

             每天23点执行一次：0 0 23 * * ?

             每天凌晨1点执行一次：0 0 1 * * ?

             每月1号凌晨1点执行一次：0 0 1 1 * ?

             每月最后一天23点执行一次：0 0 23 L * ?

             每周星期天凌晨1点实行一次：0 0 1 ? * L

             在26分、29分、33分执行一次：0 26,29,33 * * * ?

             每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?

```

## quartz state

see [org/quartz-scheduler/quartz/2.3.0/quartz-2.3.0-sources.jar!/org/quartz/impl/jdbcjobstore/Constants.java:142](/org/quartz-scheduler/quartz/2.3.0/quartz-2.3.0-sources.jar!/org/quartz/impl/jdbcjobstore/Constants.java:142)

```java

   // STATES
    String STATE_WAITING = "WAITING";

    String STATE_ACQUIRED = "ACQUIRED";

    String STATE_EXECUTING = "EXECUTING";

    String STATE_COMPLETE = "COMPLETE";

    String STATE_BLOCKED = "BLOCKED";

    String STATE_ERROR = "ERROR";

    String STATE_PAUSED = "PAUSED";

    String STATE_PAUSED_BLOCKED = "PAUSED_BLOCKED";

    String STATE_DELETED = "DELETED";

```


## mybatis plus自定义分页出错

采用mybatis plus的自定义查询报错如下：

```java
Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: cannot find column's cache for "com.yanzhi.batch.entity.JobListEntity", so you cannot used "class com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper"!
不支持，不可以使用`LambdaQueryWrapper`来构造自定义查询条件

```

那么该如何优雅的使用mybatis提供的QueryWrapper构造子查询条件呢？避免在xml中写大量的`<if test>`进行判断子查询，生成动态的查询条件，如下是操作步骤：

   1.  首先确定配置了拦截器如下：

 ```java
 /**
     * 分页拦截器
     *
     * @return
     */
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();

        List<ISqlParser> sqlParserList = new ArrayList<>();
        // 攻击 SQL 阻断解析器、加入解析链作用！阻止恶意的全表更新删除
        sqlParserList.add(new BlockAttackSqlParser());

        paginationInterceptor.setSqlParserList(sqlParserList);
        return paginationInterceptor;

    }
```

   2. 在mapper中定义对应的接口（主要看对应的两个方法参数`IPage`, `@Param(Constants.WRAPPER) Wrapper`，还有返回类型: `IPage`，其他的根据自己的实体调整）:

```java
     IPage<JobListEntity> getJobs(IPage page, @Param(Constants.WRAPPER) Wrapper entityWrapper);
```

   3. 在mapper的xml对应的查询SQL最后定义如下自定义查询:

```java
        <where>
            ${ew.sqlSegment}
        </where>
```

   4. 在service层调用mapper层的方法代码：

```java
        Page<JobListEntity> page = new Page<>(pageNum, PageSize);
        // 或者QueryWrapper queryWrapper =Wrappers.query();
        QueryWrapper queryWrapper = Wrappers.emptyWrapper(); 
        if(StrUtil.isNotEmpty(name)) {
            // 这里填的字段对应查询条件中的数据字段
            queryWrapper.like("qjd.JOB_NAME", name);
        }
        IPage<JobListEntity> jobListEntityIPage = jobMapper.getJobs(page, queryWrapper);
```

关于 `${ew.sqlSegment}` 使用了 `$` 不要误以为就会被 sql 注入，请放心使用 mp 内部对`wrapper` 进行了字符转义处理！

