--- 
title: 5月22日整理
---

## 自定义自己的application.yml中的配置信息


```
         <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

```


## spring security securedEnabled /jsr250Enabled  / prePostEnabled 


## resttemplate获取的json对象是泛型的会自动转换为map对象，如何转为正确的实体类？
```
// 泛型的数据返回值
        ParameterizedTypeReference<WebResponse<WeixinUserInfoResponse>> webResponseParameterizedTypeReference =
                new ParameterizedTypeReference<WebResponse<WeixinUserInfoResponse>>() {
                };
        ResponseEntity<WebResponse<WeixinUserInfoResponse>> responseEntity = restTemplate.
                exchange(userInfoRequestUrl, HttpMethod.GET, null, webResponseParameterizedTypeReference);
        // 获取正确了token值
        WebResponse<WeixinUserInfoResponse> webResponse = responseEntity.getBody();
```

## Data truncation: Truncated incorrect DOUBLE value 

> 在网上的主要错误原因是：update语句中的set中出现了and关键字，而应该使用逗号<,>代替之；这里的报错不属于这种情况；

## mysql表名不区分大小写

```
需要改 MySQL 的配置文件，Linux 下 MySQL 的配置文件可能是 /etc/my.cnf，或 /etc/mysql/my.cnf，这依赖于你的安装方式。假如是 /etc/my.cnf，那么执行

sudo vi /etc/my.cnf

在 [mysqld] 节中添加：

lower_case_table_names=1

然后保存，用 sudo /etc/init.d/mysql restart 重启 MySQL 服务便让 Linux 系统对表名大小写不敏感了。

其实准确来说不是说 Linux 对于 MySQL 表名忽略大小写，而是应用上面的配置后，MySQL 服务程序会来自于应用程序里的请求的表名转换为小写，如你查询 select*  UNMI_TABLE，MySQL 会认为是查询的 select * from unmi_table，所以在加入

lower_case_table_names=1

之前时你必须把表名都改为小写。也就是在创建表时都用小写名字，如果创建的表名为 UNMI_TABLE，那么程序中无论是执行 select * from UNMI_TABLE 还是执行 select * from unmi_table 都会碰到类似下面的错误：

```
但是mysql8 不能更改

遇到同样问题，翻看MySQL官方文档发现

lower_case_table_names can only be configured when initializing the server. Changing the lower_case_table_names setting after the server is initialized is prohibited.

别指望了改了

经过尝试，只有在安装完成之后，初始化数据库之前，修改my.cnf
然后再初始化数据库才有效


## spring quartz任务调度超时

[参考博客](https://www.cnblogs.com/daxin/p/3919927.html)

```yml
        jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: QRTZ_
            # 调度引擎比较忙得时候出现这个问题
            # 当前线程有10个，但是现在有12个任务需要在13:00处理，所以有两个任务需要延迟处理，
            # 如果延迟到13:60，就是延迟了60分钟， 大于下面的50分钟，所以就是misfire的。
            # 如果延迟到13:40 ，触发器发现小于50秒，调度引擎认为这个延迟时间可以忍受，所以不算超时(Misfires)
            misfireThreshold: 50000
            # 集群配置
            isClustered: false
            clusterCheckinInterval: 50000

```